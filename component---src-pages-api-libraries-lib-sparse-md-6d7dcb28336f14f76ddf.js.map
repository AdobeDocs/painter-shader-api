{"version":3,"file":"component---src-pages-api-libraries-lib-sparse-md-6d7dcb28336f14f76ddf.js","mappings":"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","sources":["webpack://dev-site-documentation-template/./src/pages/api/libraries/lib-sparse.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/runner/work/painter-shader-api/painter-shader-api/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-0\"\n      }}>{` `}</a></p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-1\"\n      }}>{` `}</a></p>\n    <h1 {...{\n      \"id\": \"lib-sparseglsl\"\n    }}>{`lib-sparse.glsl`}</h1>\n    <p>{`This file provides useful functions to ensure sparse textures sampling\ncorrectness (ARB_sparse_texture).\nAllows to sample only part of textures really present in video memory.`}</p>\n    <p><strong parentName=\"p\">{`Public Functions:`}</strong>{`\n`}<inlineCode parentName=\"p\">{`getSparseCoord`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`getSparseCoordLod0`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`textureSparseQueryLod`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`textureSparse`}</inlineCode></p>\n    <p><strong parentName=\"p\">{`Public Structures:`}</strong>{`\n`}<inlineCode parentName=\"p\">{`SamplerSparse`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`SparseCoord`}</inlineCode></p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`FEATURE_SPARSE_TEXTURE`}</inlineCode>{` macro is defined only if the sparse virtual texture extension is enabled.`}</p>\n    <p>{`If enabled, process additional texture lookup checks to climb up mipmap pyramid if texels are missing.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`#ifdef FEATURE_SPARSE_TEXTURE\n //: param auto material_lod_check_needed\n uniform bool material_lod_check_needed = false;\n //: param auto material_lod_mask\n uniform usampler2D material_lod_mask;\n #endif // FEATURE_SPARSE_TEXTURE\n //: param auto uvtile_reference_sampler\n uniform sampler2D uvtile_reference_sampler;\n //: param auto uvtile_size\n uniform vec2 uvtile_size;\n //: param auto uvtile_inverse_size\n uniform vec2 uvtile_inverse_size;\n //: param auto uvtile_lod_bias\n uniform float uvtile_lod_bias;\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-2\"\n      }}>{` `}</a></p>\n    <p>{`Sampler and sparse texture information structure`}</p>\n    <p>{`Used to query all sampler related uniforms with a single auto binding`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`struct SamplerSparse {\n  sampler2D tex;\n  vec4 size; // width, height, 1/width, 1/height\n  bool is_set; // a boolean indicating whether the texture is in the texture set or not\n  bool is_color; // a boolean indicating whether the texture is color (RGBA) or grayscale (R, GB)\n  uvec3 lod_mask_select; // masking operations description allowing to retrieve loaded mipmaps information\n };\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-3\"\n      }}>{` `}</a></p>\n    <p>{`Sparse sampling coordinates`}</p>\n    <p>{`Store the UV coordinates & material-wise sparse LoD mask`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`struct SparseCoord {\n  vec2 tex_coord;\n  vec2 dfdx;\n  vec2 dfdy;\n  float lod;\n  uint material_lod_mask;\n };\n \n \n #if defined(SHADER_FRAGMENT)\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-4\"\n      }}>{` `}</a></p>\n    <p>{`Build texture coordinates structure used by `}<inlineCode parentName=\"p\">{`textureSparse()`}</inlineCode>{` sampling function\n(must be called from fragment shader)`}</p>\n    <p>{`Example: `}<inlineCode parentName=\"p\">{`SparseCoord uv1coord = getSparseCoord(inputs.multi_tex_coord[1]);`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`SparseCoord getSparseCoord(vec2 tex_coord) {\n  SparseCoord res;\n  res.tex_coord = tex_coord;\n  res.dfdx = dFdx(tex_coord);\n  res.dfdy = dFdy(tex_coord);\n #ifdef FEATURE_SPARSE_TEXTURE\n  res.material_lod_mask = material_lod_check_needed ?\n  textureLod(material_lod_mask,tex_coord,0.0).r :\n  0u;\n  res.lod = getLodFromReferenceSampler(tex_coord);\n #endif // FEATURE_SPARSE_TEXTURE\n  return res;\n }\n #endif\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-5\"\n      }}>{` `}</a></p>\n    <p>{`Build texture coordinates structure used by `}<inlineCode parentName=\"p\">{`textureSparse()`}</inlineCode>{` sampling function\nBase level sampling version (can be used if outside fragment shader)`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`SparseCoord getSparseCoordLod0(vec2 tex_coord) {\n  SparseCoord res;\n  res.tex_coord = tex_coord;\n  res.dfdx = vec2(0.0);\n  res.dfdy = vec2(0.0);\n #ifdef FEATURE_SPARSE_TEXTURE\n  res.material_lod_mask = material_lod_check_needed ?\n  textureLod(material_lod_mask,tex_coord,0.0).r :\n  0u;\n  res.lod = 0.0;\n #endif // FEATURE_SPARSE_TEXTURE\n  return res;\n }\n \n #if defined(SHADER_FRAGMENT)\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-6\"\n      }}>{` `}</a></p>\n    <p>{`Compute the level-of-detail that would be used to sample from a sparse texture`}</p>\n    <p>{`Climb up mipmap pyramid if texels are missing\nReturns LoD BEFORE LoD bias applied`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`float textureSparseQueryLod(SamplerSparse smp, SparseCoord coord) {\n #ifdef FEATURE_SPARSE_TEXTURE\n  float lodfix = coord.lod;\n  if (material_lod_check_needed) {\n  lodfix = getFixedSparseLod(getTextureLodMask(smp.lod_mask_select, coord.material_lod_mask), lodfix);\n  }\n  return lodfix-uvtile_lod_bias;\n #else // FEATURE_SPARSE_TEXTURE\n  // Do not use textureQueryLod here: workaround of MacOS driver issue (dramatic FPS drop)\n  vec2 dx = coord.dfdx * smp.size.xy;\n  vec2 dy = coord.dfdy * smp.size.xy;\n  return max(0.0, 0.5 * log2(max(dot(dx, dx), dot(dy, dy))));\n #endif // FEATURE_SPARSE_TEXTURE\n }\n #endif // SHADER_FRAGMENT\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-7\"\n      }}>{` `}</a></p>\n    <p>{`Compute the derivatives that would be used to sample from a sparse texture`}</p>\n    <p>{`Climb up mipmap pyramid if texels are missing`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`void textureSparseQueryGrad(out vec2 dfdx, out vec2 dfdy, SamplerSparse smp, SparseCoord coord) {\n #ifdef FEATURE_SPARSE_TEXTURE\n  if (material_lod_check_needed) {\n  float lodfix = getFixedSparseLod(getTextureLodMask(smp.lod_mask_select, coord.material_lod_mask), coord.lod);\n  if (coord.lod!=lodfix) {\n  // Fix dfdx dfdy, take account offset, no more anisotropy\n  vec2 ddfix = exp2(lodfix-uvtile_lod_bias) * uvtile_inverse_size;\n  dfdx = vec2(ddfix.x,0.0);\n  dfdy = vec2(0.0,ddfix.y);\n  return;\n  }\n  }\n #endif // FEATURE_SPARSE_TEXTURE\n  dfdx = coord.dfdx;\n  dfdy = coord.dfdy;\n }\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-8\"\n      }}>{` `}</a></p>\n    <p>{`Performs a texture lookup on a sparse texture, go up the mipmap levels if necessary`}</p>\n    <p>{`This function replaces the standard `}<inlineCode parentName=\"p\">{`texture(sampler2D, vec2)`}</inlineCode>{` to retrieve texels from a sparse texture`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`vec4 textureSparse(SamplerSparse smp, SparseCoord coord) {\n  vec2 dfdx,dfdy;\n  textureSparseQueryGrad(dfdx, dfdy, smp, coord);\n  return textureGrad(smp.tex, coord.tex_coord, dfdx, dfdy);\n }\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-9\"\n      }}>{` `}</a></p>\n    <p>{`Given a texture, performs an optimized multiple texture lookups with small offsets`}</p>\n    <p>{`We are providing alternatives versions of this helper for up to N=4`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`void textureSparseOffsets(SamplerSparse smp, SparseCoord coord, vec2 offsets[N], out vec4 results[N]) {\n  vec2 dfdx,dfdy;\n  textureSparseQueryGrad(dfdx, dfdy, smp, coord);\n  for(int i = 0; i < N; ++i) {\n  results[i] = textureGrad(smp.tex, coord.tex_coord + offsets[i], dfdx, dfdy);\n  }\n }\n \n \n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","_ref","components","props","_objectWithoutPropertiesLoose","_excluded","mdx","_extends","mdxType","parentName","isMDXComponent"],"sourceRoot":""}