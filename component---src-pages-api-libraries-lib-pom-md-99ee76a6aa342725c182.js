"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[7296],{71393:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return s},default:function(){return d}});var a=t(87462),r=t(63366),o=(t(15007),t(64983)),l=t(91515),i=["components"],s={},p={_frontmatter:s},m=l.Z;function d(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.mdx)(m,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"lib-pomglsl"},"lib","-","pom.glsl"),(0,o.mdx)("hr",null),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Public Functions:"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"getParallaxOffset"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"applyParallaxOffset")),(0,o.mdx)("p",null,"Import from library"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"import lib-sampler.glsl\n")),(0,o.mdx)("p",null,"Parallax occlusion mapping related uniforms"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},'//: param auto is_2d_view\n uniform bool isTextureView;\n \n //: param auto channel_displacement\n uniform SamplerSparse displacement_texture;\n \n //: param custom {\n //:   "label": "Enable",\n //:   "default": false,\n //:   "group": "Geometry/Parallax Occlusion Mapping",\n //:   "description": "<html><head/><body><p>Simulates displacement of the surface without actually moving the mesh\'s vertices.<br/><b>Please note</b>: The following channel needs to be present for this parameter to have an effect: <b>Displacement</b></p></body></html>"\n //: }\n uniform_specialization bool usePOM;\n \n //: param custom {\n //:   "label": "Strength",\n //:   "default": 1.0,\n //:   "min": 0.01,\n //:   "max": 10.0,\n //:   "group": "Geometry/Parallax Occlusion Mapping",\n //:   "visible": "input.usePOM",\n //:   "description": "<html><head/><body><p>The strength of the simulated displacement.</p></body></html>"\n //: }\n uniform float pomStrength;\n \n //: param custom {\n //:   "label": "Minimum samples",\n //:   "default": 4,\n //:   "min": 1,\n //:   "max": 64,\n //:   "group": "Geometry/Parallax Occlusion Mapping",\n //:   "visible": "input.usePOM",\n //:   "description": "<html><head/><body><p>The minimum number of samples performed for the intersection lookup.</p></body></html>"\n //: }\n uniform int minPOMSamples;\n \n //: param custom {\n //:   "label": "Maximum samples",\n //:   "default": 16,\n //:   "min": 1,\n //:   "max": 64,\n //:   "group": "Geometry/Parallax Occlusion Mapping",\n //:   "visible": "input.usePOM",\n //:   "description": "<html><head/><body><p>The maximum number of samples performed for the intersection lookup.</p></body></html>"\n //: }\n uniform int maxPOMSamples;\n')),(0,o.mdx)("p",null,"Compute the offset of texture coordinates based on parallax"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec2 getParallaxOffset(SparseCoord coord, vec3 viewTS)\n {\n   if (!usePOM || isTextureView || !displacement_texture.is_set) return vec2(0.0);\n \n   vec2 dfdx,dfdy;\n   textureSparseQueryGrad(dfdx, dfdy, displacement_texture, coord);\n \n   // Convention: 1.0 is top, -1.0 is bottom - POM is always inward, no extrusion\n   int nbSteps = int(mix(maxPOMSamples, minPOMSamples, viewTS.z));\n   float amplitude = 4.0 * pomStrength / (HEIGHT_FACTOR * abs(viewTS.z) * nbSteps);\n   vec3 rayStep = vec3(-amplitude * viewTS.xy, -2.0 / nbSteps);\n \n   // Raymarch until we cross the surface\n   vec3 rayPos = vec3(coord.tex_coord, 1.0);\n   float prevHeight;\n   float currHeight = getDisplacement(textureGrad(displacement_texture.tex, rayPos.xy, dfdx, dfdy));\n   int i = 0;\n   do {\n     rayPos += rayStep;\n     prevHeight = currHeight;\n     currHeight = getDisplacement(textureGrad(displacement_texture.tex, rayPos.xy, dfdx, dfdy));\n     i++;\n   } while (i < nbSteps && currHeight < rayPos.z);\n \n   // Binary search with linear interpolation to refine intersection\n   vec3 prevRayPos = rayPos - rayStep;\n   vec3 newRayPos = prevRayPos;\n   float newHeight = prevHeight;\n   i = 0;\n   while (i < 3 && abs(newHeight - newRayPos.z) > 1e-3) {\n     float prevDelta = prevRayPos.z - prevHeight;\n     float delta = currHeight - rayPos.z;\n     newRayPos = (prevDelta * rayPos + delta * prevRayPos) / (prevDelta + delta);\n     newHeight = getDisplacement(textureGrad(displacement_texture.tex, newRayPos.xy, dfdx, dfdy));\n \n     if (newHeight > newRayPos.z) {\n       currHeight = newHeight;\n       rayPos = newRayPos;\n     } else {\n       prevHeight = newHeight;\n       prevRayPos = newRayPos;\n     }\n \n     i++;\n   }\n \n   return newRayPos.xy - coord.tex_coord;\n }\n")),(0,o.mdx)("p",null,"Update input texture coordinates with parallax offset"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"void applyParallaxOffset(inout V2F inputs, vec3 viewTS)\n {\n   vec2 offset = getParallaxOffset(inputs.sparse_coord, viewTS);\n   if (any(notEqual(offset,vec2(0.0)))) {\n     inputs.tex_coord += offset;\n     inputs.sparse_coord = getSparseCoord(inputs.tex_coord);\n   }\n }\n \n \n")))}d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-libraries-lib-pom-md-99ee76a6aa342725c182.js.map