"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[8502],{32625:function(e,n,a){a.r(n),a.d(n,{_frontmatter:function(){return p},default:function(){return i}});var l=a(87462),o=a(63366),t=(a(15007),a(64983)),r=a(91515),s=["components"],p={},c={_frontmatter:p},u=r.Z;function i(e){var n=e.components,a=(0,o.Z)(e,s);return(0,t.mdx)(u,(0,l.Z)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-0"}," ")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-1"}," ")),(0,t.mdx)("h1",{id:"substance-3d-painter-metalrough-pbr-shader"},"Substance 3D Painter Metal/Rough PBR shader"),(0,t.mdx)("p",null,"Import from libraries."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"import lib-pbr.glsl\n import lib-bent-normal.glsl\n import lib-emissive.glsl\n import lib-pom.glsl\n import lib-sss.glsl\n import lib-utils.glsl\n")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-2"}," ")),(0,t.mdx)("p",null,"Declare the iray mdl material to use with this shader."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},'//: metadata {\n //: "mdl":"mdl::alg::materials::skin_metallic_roughness::skin_metallic_roughness"\n //: }\n')),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-3"}," ")),(0,t.mdx)("p",null,"Channels needed for metal/rough workflow are bound here."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"//: param auto channel_basecolor\n uniform SamplerSparse basecolor_tex;\n //: param auto channel_roughness\n uniform SamplerSparse roughness_tex;\n //: param auto channel_metallic\n uniform SamplerSparse metallic_tex;\n //: param auto channel_specularlevel\n uniform SamplerSparse specularlevel_tex;\n")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-4"}," ")),(0,t.mdx)("p",null,"Shader entry point."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"void shade(V2F inputs)\n {\n  // Apply parallax occlusion mapping if possible\n  vec3 viewTS = worldSpaceToTangentSpace(getEyeVec(inputs.position), inputs);\n  applyParallaxOffset(inputs, viewTS);\n \n  // Fetch material parameters, and conversion to the specular/roughness model\n  float roughness = getRoughness(roughness_tex, inputs.sparse_coord);\n  vec3 baseColor = getBaseColor(basecolor_tex, inputs.sparse_coord);\n  float metallic = getMetallic(metallic_tex, inputs.sparse_coord);\n  float specularLevel = getSpecularLevel(specularlevel_tex, inputs.sparse_coord);\n  vec3 diffColor = generateDiffuseColor(baseColor, metallic);\n  vec3 specColor = generateSpecularColor(specularLevel, baseColor, metallic);\n \n  // Get detail (ambient occlusion) and global (shadow) occlusion factors\n  // separately in order to blend the bent normals properly\n  float shadowFactor = getShadowFactor();\n  float occlusion = getAO(inputs.sparse_coord, true, use_bent_normal);\n  float specOcclusion = specularOcclusionCorrection(\n  use_bent_normal ? shadowFactor : occlusion * shadowFactor,\n  metallic,\n  roughness);\n \n  LocalVectors vectors = computeLocalFrame(inputs);\n  computeBentNormal(vectors,inputs);\n \n  // Feed parameters for a physically based BRDF integration\n  emissiveColorOutput(pbrComputeEmissive(emissive_tex, inputs.sparse_coord));\n  albedoOutput(diffColor);\n  diffuseShadingOutput(occlusion * shadowFactor * envIrradiance(getDiffuseBentNormal(vectors)));\n  specularShadingOutput(specOcclusion * pbrComputeSpecular(vectors, specColor, roughness, occlusion, getBentNormalSpecularAmount()));\n  sssCoefficientsOutput(getSSSCoefficients(inputs.sparse_coord));\n  sssColorOutput(getSSSColor(inputs.sparse_coord));\n }\n \n \n")))}i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-shaders-pbr-metal-rough-md-91593afc16e622bd3895.js.map