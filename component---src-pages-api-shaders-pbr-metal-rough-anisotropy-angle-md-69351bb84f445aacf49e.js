"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[878],{26258:function(e,n,o){o.r(n),o.d(n,{_frontmatter:function(){return p},default:function(){return u}});var a=o(87462),t=o(63366),r=(o(15007),o(64983)),s=o(91515),l=["components"],p={},i={_frontmatter:p},c=s.Z;function u(e){var n=e.components,o=(0,t.Z)(e,l);return(0,r.mdx)(c,(0,a.Z)({},i,o,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,(0,r.mdx)("a",{parentName:"p",href:"#section-0"}," ")),(0,r.mdx)("p",null,(0,r.mdx)("a",{parentName:"p",href:"#section-1"}," ")),(0,r.mdx)("h1",{id:"substance-3d-painter-metalrough-anisotropy-pbr-shader"},"Substance 3D Painter Metal/Rough Anisotropy PBR shader"),(0,r.mdx)("hr",null),(0,r.mdx)("p",null,"Import from libraries."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-glsl"},"import lib-pbr.glsl\n import lib-pbr-aniso.glsl\n import lib-bent-normal.glsl\n import lib-emissive.glsl\n import lib-sss.glsl\n import lib-alpha.glsl\n import lib-utils.glsl\n")),(0,r.mdx)("p",null,(0,r.mdx)("a",{parentName:"p",href:"#section-2"}," ")),(0,r.mdx)("p",null,"Declare the iray mdl material to use with this shader."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-glsl"},'//: metadata {\n //: "mdl":"mdl::alg::materials::skin_metallic_roughness::skin_metallic_roughness"\n //: }\n')),(0,r.mdx)("p",null,(0,r.mdx)("a",{parentName:"p",href:"#section-3"}," ")),(0,r.mdx)("p",null,"Show back faces as there may be holes in front faces."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-glsl"},"//: state cull_face off\n")),(0,r.mdx)("p",null,(0,r.mdx)("a",{parentName:"p",href:"#section-4"}," ")),(0,r.mdx)("p",null,"Channels needed for metal/rough workflow are bound here."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-glsl"},"//: param auto channel_basecolor\n uniform SamplerSparse basecolor_tex;\n //: param auto channel_roughness\n uniform SamplerSparse roughness_tex;\n //: param auto channel_metallic\n uniform SamplerSparse metallic_tex;\n //: param auto channel_anisotropylevel\n uniform SamplerSparse anisotropylevel_tex;\n //: param auto channel_anisotropyangle\n uniform SamplerSparse anisotropyangle_tex;\n")),(0,r.mdx)("p",null,(0,r.mdx)("a",{parentName:"p",href:"#section-5"}," ")),(0,r.mdx)("p",null,"Shader entry point."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-glsl"},"void shade(V2F inputs)\n {\n \n  // Fetch material parameters, and conversion to the specular/roughness model\n  float roughness = getRoughness(roughness_tex, inputs.sparse_coord);\n  float anisotropyLevel = getAnisotropyLevel(anisotropylevel_tex, inputs.sparse_coord);\n  vec2 roughnessAniso = generateAnisotropicRoughness(roughness, anisotropyLevel);\n  float anisotropyAngle = getAnisotropyAngle(anisotropyangle_tex, inputs.sparse_coord);\n \n  vec3 baseColor = getBaseColor(basecolor_tex, inputs.sparse_coord);\n  float metallic = getMetallic(metallic_tex, inputs.sparse_coord);\n \n  // Get detail (ambient occlusion) and global (shadow) occlusion factors\n  // separately in order to blend the bent normals properly\n  float shadowFactor = getShadowFactor();\n  float occlusion = getAO(inputs.sparse_coord, true, use_bent_normal);\n  float specOcclusion = specularOcclusionCorrection(\n  use_bent_normal ? shadowFactor : occlusion * shadowFactor,\n  metallic,\n  roughness);\n \n  vec3 normal = computeWSNormal(inputs.sparse_coord, inputs.tangent, inputs.bitangent, inputs.normal);\n  LocalVectors vectors = computeLocalFrame(inputs, normal, anisotropyAngle);\n  computeBentNormal(vectors,inputs);\n \n  // Feed parameters for a physically based BRDF integration\n  alphaOutput(getOpacity(opacity_tex, inputs.sparse_coord));\n  emissiveColorOutput(pbrComputeEmissive(emissive_tex, inputs.sparse_coord));\n  sssCoefficientsOutput(getSSSCoefficients(inputs.sparse_coord));\n \n  vec4 baseSSSColor = getSSSColor(inputs.sparse_coord);\n  if (usesSSSScatteringColorChannel()) {\n  // Must be dimmed by metallic factor as for diffuse color\n  baseSSSColor.rgb = generateDiffuseColor(baseSSSColor.rgb, metallic);\n  }\n  sssColorOutput(baseSSSColor);\n \n  // Discard current fragment on the basis of the opacity channel\n  // and a user defined threshold\n  alphaKill(inputs.sparse_coord);\n \n  vec3 diffColor = generateDiffuseColor(baseColor, metallic);\n  albedoOutput(diffColor);\n  diffuseShadingOutput(occlusion * shadowFactor * envIrradiance(getDiffuseBentNormal(vectors)));\n  vec3 specColor = generateSpecularColor(baseColor, metallic);\n  specularShadingOutput(specOcclusion * pbrComputeSpecularAnisotropic(vectors, specColor, roughnessAniso, occlusion, getBentNormalSpecularAmount()));\n }\n \n \n")))}u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-shaders-pbr-metal-rough-anisotropy-angle-md-69351bb84f445aacf49e.js.map