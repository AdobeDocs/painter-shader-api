"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[2448],{22202:function(e,n,a){a.r(n),a.d(n,{_frontmatter:function(){return d},default:function(){return i}});var r=a(87462),l=a(63366),o=(a(15007),a(64983)),t=a(91515),m=["components"],d={},p={_frontmatter:d},c=t.Z;function i(e){var n=e.components,a=(0,l.Z)(e,m);return(0,o.mdx)(c,(0,r.Z)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-0"}," ")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-1"}," ")),(0,o.mdx)("h1",{id:"lib-normalglsl"},"lib-normal.glsl"),(0,o.mdx)("hr",null),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Public Functions:"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"normalBlend"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"normalBlendOriented"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"normalFade"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"normalUnpack"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"normalFromBaseNormal"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"normalFromNormal"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"normalFromHeight"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"getTSNormal"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"computeWSBaseNormal"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"computeWSNormal")),(0,o.mdx)("p",null,"Import from library"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"import lib-defines.glsl\n import lib-sparse.glsl\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-2"}," ")),(0,o.mdx)("p",null,"All engine parameters useful for normal-centric operations."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"//: param auto channel_height\n uniform SamplerSparse height_texture;\n //: param auto channel_normal\n uniform SamplerSparse normal_texture;\n //: param auto texture_normal\n uniform SamplerSparse base_normal_texture;\n //: param auto normal_blending_mode\n uniform int normal_blending_mode;\n //: param auto height_2_normal_method\n uniform int height_2_normal_method;\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-3"}," ")),(0,o.mdx)("p",null,"Used to invert the Y axis of the normal map"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"//: param auto normal_y_coeff\n uniform float base_normal_y_coeff;\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-4"}," ")),(0,o.mdx)("p",null,"Empirically determined by our artists..."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"const float HEIGHT_FACTOR = 400.0;\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-5"}," ")),(0,o.mdx)("p",null,"Perform the blending between 2 normal maps"),(0,o.mdx)("p",null,"This is based on Whiteout blending\n",(0,o.mdx)("a",{parentName:"p",href:"http://blog.selfshadow.com/publications/blending-in-detail/"},"http://blog.selfshadow.com/publications/blending-in-detail/")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 normalBlend(vec3 baseNormal, vec3 overNormal)\n {\n  return normalize(vec3(\n  baseNormal.xy + overNormal.xy,\n  baseNormal.z * overNormal.z));\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-6"}," ")),(0,o.mdx)("p",null,"Perform a detail oriented blending between 2 normal maps"),(0,o.mdx)("p",null,"This is based on Detail Oriented blending\n",(0,o.mdx)("a",{parentName:"p",href:"http://blog.selfshadow.com/publications/blending-in-detail/"},"http://blog.selfshadow.com/publications/blending-in-detail/")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 normalBlendOriented(vec3 baseNormal, vec3 overNormal)\n {\n  baseNormal.z += 1.0;\n  overNormal.xy = -overNormal.xy;\n  return normalize(baseNormal * dot(baseNormal,overNormal) -\n  overNormal*baseNormal.z);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-7"}," ")),(0,o.mdx)("p",null,"Returns a normal flattened by an attenuation factor"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 normalFade(vec3 normal,float attenuation)\n {\n  if (attenuation<1.0 && normal.z<1.0)\n  {\n  float phi = attenuation * acos(normal.z);\n  normal.xy *= 1.0/sqrt(1.0-normal.z*normal.z) * sin(phi);\n  normal.z = cos(phi);\n  }\n \n  return normal;\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-8"}," ")),(0,o.mdx)("p",null,"Unpack a normal w/ alpha channel"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 normalUnpack(vec4 normal_alpha, float y_coeff)\n {\n  if (normal_alpha.a == 0.0 || normal_alpha.xyz == vec3(0.0)) {\n  return vec3(0.0, 0.0, 1.0);\n  }\n \n  // Attenuation in function of alpha\n  vec3 normal = normal_alpha.xyz/normal_alpha.a * 2.0 - vec3(1.0);\n  normal.y *= y_coeff;\n  normal.z = max(1e-3, normal.z);\n  normal = normalize(normal);\n  normal = normalFade(normal, normal_alpha.a);\n \n  return normal;\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-9"}," ")),(0,o.mdx)("p",null,"Unpack a normal w/ alpha channel, no Y invertion"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 normalUnpack(vec4 normal_alpha)\n {\n  return normalUnpack(normal_alpha, 1.0);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-10"}," ")),(0,o.mdx)("p",null,"Compute the tangent space normal from document's height channel"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 normalFromHeight(SparseCoord coord, float height_force)\n {\n  // Normal computation using height map\n \n  // Determine gradient offset in function of derivatives\n  vec2 dfd = max(coord.dfdx,coord.dfdy);\n  dfd = max(dfd,height_texture.size.zw);\n \n  vec2 dfdx,dfdy;\n  textureSparseQueryGrad(dfdx, dfdy, height_texture, coord);\n  float h_l = textureGrad(height_texture.tex, coord.tex_coord+vec2(-dfd.x, 0 ), dfdx, dfdy).r;\n  float h_t = textureGrad(height_texture.tex, coord.tex_coord+vec2( 0, dfd.y), dfdx, dfdy).r;\n \n  vec2 dh_dudv;\n  if (height_2_normal_method==1) {\n  float h_c = textureGrad(height_texture.tex, coord.tex_coord, dfdx, dfdy).r;\n  dh_dudv = 4.0 * height_force / dfd * vec2(h_l-h_c,h_c-h_t);\n  }\n  else {\n  float h_r = textureGrad(height_texture.tex, coord.tex_coord+vec2( dfd.x, 0 ), dfdx, dfdy).r;\n  float h_b = textureGrad(height_texture.tex, coord.tex_coord+vec2( 0, -dfd.y), dfdx, dfdy).r;\n  float h_rt = textureGrad(height_texture.tex, coord.tex_coord+vec2( dfd.x, dfd.y), dfdx, dfdy).r;\n  float h_lt = textureGrad(height_texture.tex, coord.tex_coord+vec2(-dfd.x, dfd.y), dfdx, dfdy).r;\n  float h_rb = textureGrad(height_texture.tex, coord.tex_coord+vec2( dfd.x, -dfd.y), dfdx, dfdy).r;\n  float h_lb = textureGrad(height_texture.tex, coord.tex_coord+vec2(-dfd.x, -dfd.y), dfdx, dfdy).r;\n \n  dh_dudv = (0.5 * height_force) / dfd * vec2(\n  2.0*(h_l-h_r)+h_lt-h_rt+h_lb-h_rb,\n  2.0*(h_b-h_t)+h_rb-h_rt+h_lb-h_lt);\n  }\n \n  return normalize(vec3(dh_dudv, HEIGHT_FACTOR));\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-11"}," ")),(0,o.mdx)("p",null,"Helper to compute the tangent space normal from base normal and a height\nvalue, and an optional detail normal."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 getTSNormal(SparseCoord coord, SamplerSparse texture, vec3 normalFromHeight)\n {\n  vec3 normal = normalBlendOriented(\n  normalUnpack(textureSparse(texture, coord), base_normal_y_coeff),\n  normalFromHeight);\n \n  if (normal_texture.is_set) {\n  vec3 channelNormal = normalUnpack(textureSparse(normal_texture, coord));\n  if (normal_blending_mode == BlendingMode_Replace) {\n  normal = normalBlendOriented(normalFromHeight, channelNormal);\n  } else if (normal_blending_mode == BlendingMode_NM_Combine) {\n  normal = normalBlendOriented(normal, channelNormal);\n  }\n  }\n \n  return normal;\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-12"}," ")),(0,o.mdx)("p",null,"Overload that use base_normal_texture"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 getTSNormal(SparseCoord coord, vec3 normalFromHeight)\n {\n  return getTSNormal(coord, base_normal_texture, normalFromHeight);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-13"}," ")),(0,o.mdx)("p",null,"Helper to compute the tangent space normal from base normal and height, and\nan optional detail normal."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 getTSNormal(SparseCoord coord, SamplerSparse texture)\n {\n  float height_force = 1.0;\n  vec3 normalH = normalFromHeight(coord, height_force);\n  return getTSNormal(coord, texture, normalH);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-14"}," ")),(0,o.mdx)("p",null,"Overload that use base_normal_texture"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 getTSNormal(SparseCoord coord)\n {\n  return getTSNormal(coord, base_normal_texture);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-15"}," ")),(0,o.mdx)("p",null,"Helper to compute the world space normal from tangent space base normal."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 computeWSBaseNormal(SparseCoord coord, vec3 tangent, vec3 bitangent, vec3 normal)\n {\n  vec3 normal_vec = normalUnpack(textureSparse(normal_texture, coord), base_normal_y_coeff);\n  return normalize(\n  normal_vec.x * tangent +\n  normal_vec.y * bitangent +\n  normal_vec.z * normal\n  );\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-16"}," ")),(0,o.mdx)("p",null,"Helper to compute the world space normal from tangent space normal given by\ngetTSNormal helpers, and local frame of the mesh."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 computeWSNormal(SparseCoord coord, vec3 tangent, vec3 bitangent, vec3 normal)\n {\n  vec3 normal_vec = getTSNormal(coord);\n  return normalize(\n  normal_vec.x * tangent +\n  normal_vec.y * bitangent +\n  normal_vec.z * normal\n  );\n }\n \n \n")))}i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-libraries-lib-normal-md-5d9176d28f4edbb08123.js.map