"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[5364],{10630:function(n,a,e){e.r(a),e.d(a,{_frontmatter:function(){return m},default:function(){return c}});var l=e(87462),r=e(63366),o=(e(15007),e(64983)),s=e(91515),t=["components"],m={},i={_frontmatter:m},u=s.Z;function c(n){var a=n.components,e=(0,r.Z)(n,t);return(0,o.mdx)(u,(0,l.Z)({},i,e,{components:a,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"pbr-material-layering.glsl"),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-0"}," ")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-1"}," ")),(0,o.mdx)("h1",{id:"substance-3d-painter-material-layering-pbr-shader"},"Substance 3D Painter Material Layering PBR shader"),(0,o.mdx)("p",null,"Import from libraries."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},'import lib-pbr.glsl\n import lib-emissive.glsl\n import lib-sampler.glsl\n import lib-utils.glsl\n \n #define NB_MATERIALS 4\n #define NB_MASKS (NB_MATERIALS - 1)\n \n //: metadata {\n //: "custom-ui": "material-layering/custom-ui.qml"\n //: }\n \n //: materials [\n //: {\n //: "id": "Material1",\n //: "label": "Material 1",\n //: "default": "",\n //: "size": 1024,\n //: "default_color": [0.5, 0.5, 0.5]\n //: },\n //: {\n //: "id": "Material2",\n //: "label": "Material 2",\n //: "default": "",\n //: "size": 1024,\n //: "default_color": [0.5, 0.5, 0.5]\n //: },\n //: {\n //: "id": "Material3",\n //: "label": "Material 3",\n //: "default": "",\n //: "size": 1024,\n //: "default_color": [0.5, 0.5, 0.5]\n //: },\n //: {\n //: "id": "Material4",\n //: "label": "Material 4",\n //: "default": "",\n //: "size": 1024,\n //: "default_color": [0.5, 0.5, 0.5]\n //: }\n //: ]\n \n \n //: stacks [\n //: {\n //: "id": "Mask",\n //: "channels":\n //: [\n //: {"id": "blendingmask"}\n //: ]\n //: },\n //: {\n //: "id": "Mask2",\n //: "channels":\n //: [\n //: {"id": "blendingmask"}\n //: ]\n //: },\n //: {\n //: "id": "Mask3",\n //: "channels":\n //: [\n //: {"id": "blendingmask"}\n //: ]\n //: }\n //: ]\n \n \n \n //: param custom { "default": false, "label": "Debug Mode" }\n uniform bool DebugMode;\n \n //: param custom {\n //: "default": 0,\n //: "label": "Debug channel",\n //: "widget": "combobox",\n //: "values": {\n //: "BaseColor": 0,\n //: "Roughness": 1,\n //: "Metallic": 2,\n //: "Normal (Material)": 3,\n //: "Normal (Masks)": 4,\n //: "Normal (Combined)": 5,\n //: "Mask 1": 6,\n //: "Mask 2": 7,\n //: "Mask 3": 8\n //: }\n //: }\n uniform int DebugChannel;\n \n \n //: param custom { "default": false, "label": "Normal from Masks" }\n uniform bool UseNormalFromMask;\n')),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-2"}," ")),(0,o.mdx)("hr",null),(0,o.mdx)("h2",{id:"channels-needed-for-metalrough-workflow-are-bound-here"},"Channels needed for metal/rough workflow are bound here."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},'//: param auto texture_normal;\n uniform sampler2D mesh_normal_texture;\n \n //: param custom { "default": 5, "label": "Material 1 coords", "min": 0.01, "max": 128.0, "group" : "Material 1" }\n uniform float u_coords1;\n \n //: param custom { "default": 5, "label": "Material 2 coords", "min": 0.01, "max": 128.0, "group" : "Material 2" }\n uniform float u_coords2;\n \n //: param custom { "default": 5, "label": "Material 3 coords", "min": 0.01, "max": 128.0, "group" : "Material 3" }\n uniform float u_coords3;\n \n //: param custom { "default": 5, "label": "Material 4 coords", "min": 0.01, "max": 128.0, "group" : "Material 4" }\n uniform float u_coords4;\n \n \n //: param custom { "default": 1, "label": "Normal Intensity 1", "min": 0.0, "max": 1.0, "group" : "Material 1" }\n uniform float normal_intensity1;\n \n //: param custom { "default": 1, "label": "Normal Intensity 2", "min": 0.0, "max": 1.0, "group" : "Material 2" }\n uniform float normal_intensity2;\n \n //: param custom { "default": 1, "label": "Normal Intensity 3", "min": 0.0, "max": 1.0, "group" : "Material 3" }\n uniform float normal_intensity3;\n \n //: param custom { "default": 1, "label": "Normal Intensity 4", "min": 0.0, "max": 1.0, "group" : "Material 4" }\n uniform float normal_intensity4;\n \n \n //: param custom { "default": 0, "label": "Normal from Mask Intensity 2", "min": -10.0, "max": 10.0, "group" : "Material 2" }\n uniform float mask_normal_intensity1;\n \n //: param custom { "default": 0, "label": "Normal from Mask Intensity 3", "min": -10.0, "max": 10.0, "group" : "Material 3" }\n uniform float mask_normal_intensity2;\n \n //: param custom { "default": 0, "label": "Normal from Mask Intensity 4", "min": -10.0, "max": 10.0, "group" : "Material 4" }\n uniform float mask_normal_intensity3;\n \n \n //: param custom { "default": 0.1, "label": "Normal from Mask 1 Offset", "min": 0.0, "max": 1, "group" : "Material 2" }\n uniform float mask_normal_offset1;\n \n //: param custom { "default": 0.1, "label": "Normal from Mask 2 Offset", "min": 0.0, "max": 1, "group" : "Material 3" }\n uniform float mask_normal_offset2;\n \n //: param custom { "default": 0.1, "label": "Normal from Mask 3 Offset", "min": 0.0, "max": 1, "group" : "Material 4" }\n uniform float mask_normal_offset3;\n \n \n //: param auto Material1.channel_basecolor\n uniform sampler2D color1;\n \n //: param auto Material1.channel_roughness\n uniform sampler2D rough1;\n \n //: param auto Material1.channel_metallic\n uniform sampler2D metal1;\n \n //: param auto Material1.channel_normal\n uniform sampler2D normal1;\n \n \n //: param auto Material2.channel_basecolor\n uniform sampler2D color2;\n \n //: param auto Material2.channel_roughness\n uniform sampler2D rough2;\n \n //: param auto Material2.channel_metallic\n uniform sampler2D metal2;\n \n //: param auto Material2.channel_normal\n uniform sampler2D normal2;\n \n \n //: param auto Material3.channel_basecolor\n uniform sampler2D color3;\n \n //: param auto Material3.channel_roughness\n uniform sampler2D rough3;\n \n //: param auto Material3.channel_metallic\n uniform sampler2D metal3;\n \n //: param auto Material3.channel_normal\n uniform sampler2D normal3;\n \n \n //: param auto Material4.channel_basecolor\n uniform sampler2D color4;\n \n //: param auto Material4.channel_roughness\n uniform sampler2D rough4;\n \n //: param auto Material4.channel_metallic\n uniform sampler2D metal4;\n \n //: param auto Material4.channel_normal\n uniform sampler2D normal4;\n \n \n //: param auto Mask.channel_blendingmask\n uniform SamplerSparse mask;\n \n //: param auto Mask2.channel_blendingmask\n uniform SamplerSparse mask2;\n \n //: param auto Mask3.channel_blendingmask\n uniform SamplerSparse mask3;\n \n /////////////////////////////////////////\n ////////// BLENDING FUNCTIONS ///////////\n /////////////////////////////////////////\n \n float mixGrayscale(\n  float channelSampled[NB_MATERIALS],\n  float Masks[NB_MASKS])\n {\n  float result = channelSampled[0];\n  for (int i = 0; i < NB_MASKS; i++)\n  result = mix(result, channelSampled[i + 1], Masks[i]);\n \n  return result;\n }\n \n vec3 mixColor(\n  vec3 channelSampled[NB_MATERIALS],\n  float Masks[NB_MASKS])\n {\n  vec3 result = channelSampled[0];\n  for (int i = 0; i < NB_MASKS; i++)\n  result = mix(result, channelSampled[i + 1], Masks[i]);\n \n  return result;\n }\n \n vec3 mixNormal(\n  vec3 channelSampled[NB_MATERIALS],\n  float Masks[NB_MASKS],\n  float NormalIntensity[NB_MATERIALS])\n {\n  vec3 result = NormalIntensity[0] * channelSampled[0];\n  for (int i = 0; i < NB_MASKS; i++)\n  result = mix(result, NormalIntensity[i + 1] * channelSampled[i + 1], Masks[i]);\n \n  return result;\n }\n \n vec3 NormalFromMask(SamplerSparse Mask, float Offset, float Intensity, SparseCoord UVs, float refMask)\n {\n  vec4 results[2];\n  vec2 offsets[2] = vec2[2](\n  vec2(Offset * 0.001, 0.0),\n  vec2(0.0, Offset * 0.001)\n  );\n  textureSparseOffsets(Mask, UVs, offsets, results);\n \n  float Channel1 = results[0].r - refMask;\n  float Channel2 = results[1].r - refMask;\n \n  return vec3(-Intensity * Channel1, -Intensity * Channel2, 1.0);\n }\n \n vec3 NormalFromMasks(\n  vec3 normalFromMaskSampled[NB_MASKS],\n  float Masks[NB_MASKS])\n {\n  vec3 result = normalFromMaskSampled[0];\n  for (int i = 1; i < NB_MASKS; i++)\n  result = mix(result, normalFromMaskSampled[i], Masks[i]);\n \n  return result;\n }\n \n \n void shade(V2F inputs)\n {\n')),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-3"}," ")),(0,o.mdx)("hr",null),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"}," //Global textures\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-4"}," ")),(0,o.mdx)("hr",null),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"}," // Get detail (ambient occlusion) and global (shadow) occlusion factors\n  float occlusion = getAO(inputs.sparse_coord) * getShadowFactor();\n  vec3 mesh_normal = normalUnpack(textureSparse(base_normal_texture, inputs.sparse_coord), base_normal_y_coeff);\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-5"}," ")),(0,o.mdx)("hr",null),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"}," //Materials Masks\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-6"}," ")),(0,o.mdx)("hr",null),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"}," float UVscale[NB_MATERIALS] = float[NB_MATERIALS](\n  u_coords1, u_coords2, u_coords3, u_coords4);\n \n  float NormalIntensity[NB_MATERIALS] = float[NB_MATERIALS](\n  normal_intensity1, normal_intensity2, normal_intensity3, normal_intensity4);\n \n  float MaskNormalOffset[NB_MASKS] = float[NB_MASKS](\n  mask_normal_offset1, mask_normal_offset2, mask_normal_offset3);\n \n  float MaskNormalIntensity[NB_MASKS] = float[NB_MASKS](\n  mask_normal_intensity1, mask_normal_intensity2, mask_normal_intensity3);\n \n  float Masks[NB_MASKS] = float[NB_MASKS](\n  textureSparse(mask , inputs.sparse_coord).r,\n  textureSparse(mask2, inputs.sparse_coord).r,\n  textureSparse(mask3, inputs.sparse_coord).r);\n \n  float roughSampled[NB_MATERIALS] = float[NB_MATERIALS](\n  getRoughness(rough1, inputs.tex_coord*UVscale[0]),\n  getRoughness(rough2, inputs.tex_coord*UVscale[1]),\n  getRoughness(rough3, inputs.tex_coord*UVscale[2]),\n  getRoughness(rough4, inputs.tex_coord*UVscale[3])\n  );\n \n  float metallicSampled[NB_MATERIALS] = float[NB_MATERIALS](\n  getMetallic(metal1, inputs.tex_coord*UVscale[0]),\n  getMetallic(metal2, inputs.tex_coord*UVscale[1]),\n  getMetallic(metal3, inputs.tex_coord*UVscale[2]),\n  getMetallic(metal4, inputs.tex_coord*UVscale[3])\n  );\n \n  vec3 basecolorSampled[NB_MATERIALS] = vec3[NB_MATERIALS](\n  getBaseColor(color1, inputs.tex_coord*UVscale[0]),\n  getBaseColor(color2, inputs.tex_coord*UVscale[1]),\n  getBaseColor(color3, inputs.tex_coord*UVscale[2]),\n  getBaseColor(color4, inputs.tex_coord*UVscale[3])\n  );\n \n  vec3 normalSampled[NB_MATERIALS] = vec3[NB_MATERIALS](\n  normalUnpack(texture(normal1, inputs.tex_coord*UVscale[0])),\n  normalUnpack(texture(normal2, inputs.tex_coord*UVscale[1])),\n  normalUnpack(texture(normal3, inputs.tex_coord*UVscale[2])),\n  normalUnpack(texture(normal4, inputs.tex_coord*UVscale[3]))\n  );\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-7"}," ")),(0,o.mdx)("hr",null),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"}," //Mixing\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-8"}," ")),(0,o.mdx)("hr",null),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"}," float roughness = mixGrayscale(roughSampled, Masks);\n  float metallic = mixGrayscale(metallicSampled, Masks);\n  vec3 basecolor = mixColor(basecolorSampled, Masks);\n  vec3 diffColor = generateDiffuseColor(basecolor, metallic);\n  vec3 specColor = generateSpecularColor(basecolor, metallic);\n  float specOcclusion = specularOcclusionCorrection(occlusion, metallic, roughness);\n \n  //Normal channel\n  vec3 normal = mixNormal(normalSampled, Masks, NormalIntensity);\n  normal = normalize( vec3(normal.xy + mesh_normal.xy, mesh_normal.z) ); //UDN combine method\n \n  vec3 finalNormal = normal;\n  vec3 normalMask = vec3(0.0, 0.0, 1.0);\n \n  if( UseNormalFromMask )\n  {\n  vec3 normalFromMaskSampled[NB_MASKS] = vec3[NB_MASKS](\n  NormalFromMask(mask , MaskNormalOffset[0], MaskNormalIntensity[0], inputs.sparse_coord, Masks[0]),\n  NormalFromMask(mask2, MaskNormalOffset[1], MaskNormalIntensity[1], inputs.sparse_coord, Masks[1]),\n  NormalFromMask(mask3, MaskNormalOffset[2], MaskNormalIntensity[2], inputs.sparse_coord, Masks[2])\n  );\n \n  normalMask = NormalFromMasks(normalFromMaskSampled, Masks);\n  finalNormal = normalize( vec3(finalNormal.xy + normalMask.xy, finalNormal.z) ); //UDN combine method\n  }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-9"}," ")),(0,o.mdx)("hr",null),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"}," //Final\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-10"}," ")),(0,o.mdx)("hr",null),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"}," //Debug mode display result of combined channels or Masks\n  if( !DebugMode ) {\n  vec3 finalNormalWorldSpace = normalize(\n  finalNormal.x * inputs.tangent +\n  finalNormal.y * inputs.bitangent +\n  finalNormal.z * inputs.normal);\n  // Feed parameters for a physically based BRDF integration.\n  LocalVectors vectors = computeLocalFrame(inputs, finalNormalWorldSpace, 0.0);\n  emissiveColorOutput(pbrComputeEmissive(emissive_tex, inputs.sparse_coord));\n  diffuseShadingOutput(occlusion * pbrComputeDiffuse(vectors.normal, diffColor));\n  specularShadingOutput(specOcclusion * pbrComputeSpecular(vectors, specColor, roughness));\n  } else {\n  vec3 result;\n \n  //BaseColor combined\n  if( DebugChannel == 0 ) {\n  result = basecolor;\n  }\n \n  //Roughness combined\n  else if( DebugChannel == 1 ) {\n  result = vec3(roughness);\n  }\n \n  //Metallic combined\n  else if( DebugChannel == 2 ) {\n  result = vec3(metallic);\n  }\n \n  //Normal combined\n  else if( DebugChannel == 3) {\n  normal = 0.5 * normal + vec3(0.5);\n  result = sRGB2linear(normal);\n  }\n \n  //Combined masks as Normal\n  else if( DebugChannel == 4 ) {\n  normalMask = 0.5 * normalMask + vec3(0.5);\n  result = sRGB2linear(normalMask);\n  }\n \n  //Final Normal\n  else if( DebugChannel == 5 ) {\n  finalNormal = 0.5 * finalNormal + vec3(0.5);\n  result = sRGB2linear(finalNormal);\n  }\n \n  //Mask(s)\n  else {\n  result = vec3(sRGB2linear(Masks[DebugChannel - 6]));\n  }\n \n  diffuseShadingOutput(result);\n  }\n }\n \n \n")))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-shaders-pbr-material-layering-md-e76bdaebcd771290cf39.js.map