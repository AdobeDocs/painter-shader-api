{"version":3,"file":"component---src-pages-api-shaders-pbr-metal-rough-anisotropy-angle-md-cae39829683cae43ca30.js","mappings":"mTAMaA,EAAe,CAAC,EACvBC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAUC,GAG/B,IAFDC,EAAUD,EAAVC,WACGC,GAAKC,EAAAA,EAAAA,GAAAH,EAAAI,GAER,OAAOC,EAAAA,EAAAA,KAACR,GAASS,EAAAA,EAAAA,GAAA,GAAKV,EAAiBM,EAAK,CAAED,WAAYA,EAAYM,QAAQ,eAG5EF,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,MACE,GAAM,yDAAuD,2DAE/DA,EAAAA,EAAAA,KAAA,YACAA,EAAAA,EAAAA,KAAA,oCACAA,EAAAA,EAAAA,KAAA,YAAKA,EAAAA,EAAAA,KAAA,QAAMG,WAAW,MAClB,UAAa,iBAAe,sLAShCH,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,oEACAA,EAAAA,EAAAA,KAAA,YAAKA,EAAAA,EAAAA,KAAA,QAAMG,WAAW,MAClB,UAAa,iBAAe,kHAKhCH,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,mEACAA,EAAAA,EAAAA,KAAA,YAAKA,EAAAA,EAAAA,KAAA,QAAMG,WAAW,MAClB,UAAa,iBAAe,+BAGhCH,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,sEACAA,EAAAA,EAAAA,KAAA,YAAKA,EAAAA,EAAAA,KAAA,QAAMG,WAAW,MAClB,UAAa,iBAAe,6YAYhCH,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,iCACAA,EAAAA,EAAAA,KAAA,YAAKA,EAAAA,EAAAA,KAAA,QAAMG,WAAW,MAClB,UAAa,iBAAe,6iEA+CpC,CAEAT,EAAWU,gBAAiB,C","sources":["webpack://dev-site-documentation-template/./src/pages/api/shaders/pbr-metal-rough-anisotropy-angle.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/runner/work/painter-shader-api/painter-shader-api/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-0\"\n      }}>{` `}</a></p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-1\"\n      }}>{` `}</a></p>\n    <h1 {...{\n      \"id\": \"substance-3d-painter-metalrough-anisotropy-pbr-shader\"\n    }}>{`Substance 3D Painter Metal/Rough Anisotropy PBR shader`}</h1>\n    <hr></hr>\n    <p>{`Import from libraries.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`import lib-pbr.glsl\n import lib-pbr-aniso.glsl\n import lib-bent-normal.glsl\n import lib-emissive.glsl\n import lib-sss.glsl\n import lib-alpha.glsl\n import lib-utils.glsl\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-2\"\n      }}>{` `}</a></p>\n    <p>{`Declare the iray mdl material to use with this shader.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`//: metadata {\n //: \"mdl\":\"mdl::alg::materials::skin_metallic_roughness::skin_metallic_roughness\"\n //: }\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-3\"\n      }}>{` `}</a></p>\n    <p>{`Show back faces as there may be holes in front faces.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`//: state cull_face off\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-4\"\n      }}>{` `}</a></p>\n    <p>{`Channels needed for metal/rough workflow are bound here.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`//: param auto channel_basecolor\n uniform SamplerSparse basecolor_tex;\n //: param auto channel_roughness\n uniform SamplerSparse roughness_tex;\n //: param auto channel_metallic\n uniform SamplerSparse metallic_tex;\n //: param auto channel_anisotropylevel\n uniform SamplerSparse anisotropylevel_tex;\n //: param auto channel_anisotropyangle\n uniform SamplerSparse anisotropyangle_tex;\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-5\"\n      }}>{` `}</a></p>\n    <p>{`Shader entry point.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`void shade(V2F inputs)\n {\n \n  // Fetch material parameters, and conversion to the specular/roughness model\n  float roughness = getRoughness(roughness_tex, inputs.sparse_coord);\n  float anisotropyLevel = getAnisotropyLevel(anisotropylevel_tex, inputs.sparse_coord);\n  vec2 roughnessAniso = generateAnisotropicRoughness(roughness, anisotropyLevel);\n  float anisotropyAngle = getAnisotropyAngle(anisotropyangle_tex, inputs.sparse_coord);\n \n  vec3 baseColor = getBaseColor(basecolor_tex, inputs.sparse_coord);\n  float metallic = getMetallic(metallic_tex, inputs.sparse_coord);\n \n  // Get detail (ambient occlusion) and global (shadow) occlusion factors\n  // separately in order to blend the bent normals properly\n  float shadowFactor = getShadowFactor();\n  float occlusion = getAO(inputs.sparse_coord, true, use_bent_normal);\n  float specOcclusion = specularOcclusionCorrection(\n  use_bent_normal ? shadowFactor : occlusion * shadowFactor,\n  metallic,\n  roughness);\n \n  vec3 normal = computeWSNormal(inputs.sparse_coord, inputs.tangent, inputs.bitangent, inputs.normal);\n  LocalVectors vectors = computeLocalFrame(inputs, normal, anisotropyAngle);\n  computeBentNormal(vectors,inputs);\n \n  // Feed parameters for a physically based BRDF integration\n  alphaOutput(getOpacity(opacity_tex, inputs.sparse_coord));\n  emissiveColorOutput(pbrComputeEmissive(emissive_tex, inputs.sparse_coord));\n  sssCoefficientsOutput(getSSSCoefficients(inputs.sparse_coord));\n  sssColorOutput(getSSSColor(inputs.sparse_coord));\n \n  // Discard current fragment on the basis of the opacity channel\n  // and a user defined threshold\n  alphaKill(inputs.sparse_coord);\n \n  vec3 diffColor = generateDiffuseColor(baseColor, metallic);\n  albedoOutput(diffColor);\n  diffuseShadingOutput(occlusion * shadowFactor * envIrradiance(getDiffuseBentNormal(vectors)));\n  vec3 specColor = generateSpecularColor(baseColor, metallic);\n  specularShadingOutput(specOcclusion * pbrComputeSpecularAnisotropic(vectors, specColor, roughnessAniso, occlusion, getBentNormalSpecularAmount()));\n }\n \n \n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","_ref","components","props","_objectWithoutPropertiesLoose","_excluded","mdx","_extends","mdxType","parentName","isMDXComponent"],"sourceRoot":""}