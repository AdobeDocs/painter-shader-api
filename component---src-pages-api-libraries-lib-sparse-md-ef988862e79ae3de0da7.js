"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[5042],{18368:function(e,r,d){d.r(r),d.d(r,{_frontmatter:function(){return s},default:function(){return p}});var n=d(87462),a=d(63366),o=(d(15007),d(64983)),t=d(91515),l=["components"],s={},i={_frontmatter:s},m=t.Z;function p(e){var r=e.components,d=(0,a.Z)(e,l);return(0,o.mdx)(m,(0,n.Z)({},i,d,{components:r,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"lib-sparseglsl"},"lib","-","sparse.glsl"),(0,o.mdx)("hr",null),(0,o.mdx)("p",null,"This file provides useful functions to ensure sparse textures sampling\ncorrectness (ARB_sparse_texture).\nAllows to sample only part of textures really present in video memory."),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Public Functions:"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"getSparseCoord"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"getSparseCoordLod0"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"textureSparseQueryLod"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"textureSparse")),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Public Structures:"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"SamplerSparse"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"SparseCoord")),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"FEATURE_SPARSE_TEXTURE")," macro is defined only if the sparse virtual texture extension is enabled."),(0,o.mdx)("p",null,"If enabled, process additional texture lookup checks to climb up mipmap pyramid if texels are missing."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"#ifdef FEATURE_SPARSE_TEXTURE\n //: param auto material_lod_check_needed\n uniform bool material_lod_check_needed = false;\n //: param auto material_lod_mask\n uniform usampler2D material_lod_mask;\n #endif // FEATURE_SPARSE_TEXTURE\n //: param auto uvtile_reference_sampler\n uniform sampler2D uvtile_reference_sampler;\n //: param auto uvtile_size\n uniform vec2 uvtile_size;\n //: param auto uvtile_inverse_size\n uniform vec2 uvtile_inverse_size;\n //: param auto uvtile_lod_bias\n uniform float uvtile_lod_bias;\n")),(0,o.mdx)("p",null,"Sampler and sparse texture information structure"),(0,o.mdx)("p",null,"Used to query all sampler related uniforms with a single auto binding"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"struct SamplerSparse {\n   sampler2D tex;\n   vec4 size; // width, height, 1/width, 1/height\n   bool is_set;   // a boolean indicating whether the texture is in the texture set or not\n   bool is_color; // a boolean indicating whether the texture is color (RGBA) or grayscale (R, GB)\n   uvec3 lod_mask_select; // masking operations description allowing to retrieve loaded mipmaps information\n };\n")),(0,o.mdx)("p",null,"Sparse sampling coordinates"),(0,o.mdx)("p",null,"Store the UV coordinates \\& material","-","wise sparse LoD mask"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"struct SparseCoord {\n   vec2 tex_coord;\n   vec2 dfdx;\n   vec2 dfdy;\n   float lod;\n   uint material_lod_mask;\n };\n \n \n #if defined(SHADER_FRAGMENT)\n")),(0,o.mdx)("p",null,"Build texture coordinates structure used by ",(0,o.mdx)("inlineCode",{parentName:"p"},"textureSparse()")," sampling function\n(must be called from fragment shader)"),(0,o.mdx)("p",null,"Example: ",(0,o.mdx)("inlineCode",{parentName:"p"},"SparseCoord uv1coord = getSparseCoord(inputs.multi_tex_coord[1]);")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"SparseCoord getSparseCoord(vec2 tex_coord) {\n   SparseCoord res;\n   res.tex_coord = tex_coord;\n   res.dfdx = dFdx(tex_coord);\n   res.dfdy = dFdy(tex_coord);\n #ifdef FEATURE_SPARSE_TEXTURE\n   res.material_lod_mask = material_lod_check_needed ?\n     textureLod(material_lod_mask,tex_coord,0.0).r :\n     0u;\n   res.lod = getLodFromReferenceSampler(tex_coord);\n #endif // FEATURE_SPARSE_TEXTURE\n   return res;\n }\n #endif\n")),(0,o.mdx)("p",null,"Build texture coordinates structure used by ",(0,o.mdx)("inlineCode",{parentName:"p"},"textureSparse()")," sampling function\nBase level sampling version (can be used if outside fragment shader)"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"SparseCoord getSparseCoordLod0(vec2 tex_coord) {\n   SparseCoord res;\n   res.tex_coord = tex_coord;\n   res.dfdx = vec2(0.0);\n   res.dfdy = vec2(0.0);\n #ifdef FEATURE_SPARSE_TEXTURE\n   res.material_lod_mask = material_lod_check_needed ?\n     textureLod(material_lod_mask,tex_coord,0.0).r :\n     0u;\n   res.lod = 0.0;\n #endif // FEATURE_SPARSE_TEXTURE\n   return res;\n }\n \n #if defined(SHADER_FRAGMENT)\n")),(0,o.mdx)("p",null,"Compute the level","-","of","-","detail that would be used to sample from a sparse texture"),(0,o.mdx)("p",null,"Climb up mipmap pyramid if texels are missing\nReturns LoD BEFORE LoD bias applied"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"float textureSparseQueryLod(SamplerSparse smp, SparseCoord coord) {\n #ifdef FEATURE_SPARSE_TEXTURE\n   float lodfix = coord.lod;\n   if (material_lod_check_needed) {\n     lodfix = getFixedSparseLod(getTextureLodMask(smp.lod_mask_select, coord.material_lod_mask), lodfix);\n   }\n   return lodfix-uvtile_lod_bias;\n #else // FEATURE_SPARSE_TEXTURE\n   // Do not use textureQueryLod here: workaround of MacOS driver issue (dramatic FPS drop)\n   vec2 dx = coord.dfdx * smp.size.xy;\n   vec2 dy = coord.dfdy * smp.size.xy;\n   return max(0.0, 0.5 * log2(max(dot(dx, dx), dot(dy, dy))));\n #endif // FEATURE_SPARSE_TEXTURE\n }\n #endif // SHADER_FRAGMENT\n")),(0,o.mdx)("p",null,"Compute the derivatives that would be used to sample from a sparse texture"),(0,o.mdx)("p",null,"Climb up mipmap pyramid if texels are missing"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"void textureSparseQueryGrad(out vec2 dfdx, out vec2 dfdy, SamplerSparse smp, SparseCoord coord) {\n #ifdef FEATURE_SPARSE_TEXTURE\n   if (material_lod_check_needed) {\n     float lodfix = getFixedSparseLod(getTextureLodMask(smp.lod_mask_select, coord.material_lod_mask), coord.lod);\n     if (coord.lod!=lodfix) {\n       // Fix dfdx dfdy, take account offset, no more anisotropy\n       vec2 ddfix = exp2(lodfix-uvtile_lod_bias) * uvtile_inverse_size;\n       dfdx = vec2(ddfix.x,0.0);\n       dfdy = vec2(0.0,ddfix.y);\n       return;\n     }\n   }\n #endif // FEATURE_SPARSE_TEXTURE\n   dfdx = coord.dfdx;\n   dfdy = coord.dfdy;\n }\n")),(0,o.mdx)("p",null,"Performs a texture lookup on a sparse texture, go up the mipmap levels if necessary"),(0,o.mdx)("p",null,"This function replaces the standard ",(0,o.mdx)("inlineCode",{parentName:"p"},"texture(sampler2D, vec2)")," to retrieve texels from a sparse texture"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec4 textureSparse(SamplerSparse smp, SparseCoord coord) {\n   vec2 dfdx,dfdy;\n   textureSparseQueryGrad(dfdx, dfdy, smp, coord);\n   return textureGrad(smp.tex, coord.tex_coord, dfdx, dfdy);\n }\n")),(0,o.mdx)("p",null,"Given a texture, performs an optimized multiple texture lookups with small offsets"),(0,o.mdx)("p",null,"We are providing alternatives versions of this helper for up to N\\=4"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"void textureSparseOffsets(SamplerSparse smp, SparseCoord coord, vec2 offsets[N], out vec4 results[N]) {\n   vec2 dfdx,dfdy;\n   textureSparseQueryGrad(dfdx, dfdy, smp, coord);\n   for(int i = 0; i < N; ++i) {\n     results[i] = textureGrad(smp.tex, coord.tex_coord + offsets[i], dfdx, dfdy);\n   }\n }\n \n \n")))}p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-libraries-lib-sparse-md-ef988862e79ae3de0da7.js.map