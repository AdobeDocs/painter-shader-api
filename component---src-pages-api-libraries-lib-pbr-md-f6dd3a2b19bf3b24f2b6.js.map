{"version":3,"file":"component---src-pages-api-libraries-lib-pbr-md-f6dd3a2b19bf3b24f2b6.js","mappings":"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","sources":["webpack://dev-site-documentation-template/./src/pages/api/libraries/lib-pbr.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/runner/work/painter-shader-api/painter-shader-api/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-0\"\n      }}>{`#`}</a></p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-1\"\n      }}>{`#`}</a></p>\n    <h1 {...{\n      \"id\": \"lib-pbrglsl\"\n    }}>{`lib`}{`-`}{`pbr.glsl`}</h1>\n    <hr></hr>\n    <p><strong parentName=\"p\">{`Public Functions:`}</strong>{`\n`}<inlineCode parentName=\"p\">{`normal_distrib`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`fresnel`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`G1`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`visibility`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`horizonFading`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pbrComputeDiffuse`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pbrComputeSpecular`}</inlineCode></p>\n    <p>{`Number of miplevels in the envmap.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`//: param auto environment_max_lod\n uniform float maxLod;\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-2\"\n      }}>{`#`}</a></p>\n    <p>{`An int representing the number of samples made for specular contribution\ncomputation. The more the higher quality and the performance impact.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`//: param custom {\n //:   \"default\": 16,\n //:   \"label\": \"Specular quality\",\n //:   \"widget\": \"combobox\",\n //:   \"values\": {\n //:     \"Very low (4 spp)\": 4,\n //:     \"Low (16 spp)\": 16,\n //:     \"Medium (32 spp)\": 32,\n //:     \"High (64 spp)\": 64,\n //:     \"Very high (128 spp)\": 128,\n //:     \"Ultra (256 spp)\": 256\n //:   },\n //:   \"group\": \"Base Surface\",\n //:   \"description\": \"<html><head/><body><p>The quality of the specular reflection. Choose the number of samples per pixel (SPP).</p></body></html>\"\n //: }\n uniform int nbSamples;\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-3\"\n      }}>{`#`}</a></p>\n    <p>{`Value used to control specular reflection leaking through the surface.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`//: param custom {\n //:   \"default\": 1.3,\n //:   \"label\": \"Horizon fading\",\n //:   \"min\": 0.0,\n //:   \"max\": 2.0,\n //:   \"group\": \"Base Surface\",\n //:   \"description\": \"<html><head/><body><p>Reduces unexpected specular reflection at angles pointing beneath the surface horizon.</p></body></html>\"\n //: }\n uniform float horizonFade;\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-4\"\n      }}>{`#`}</a></p>\n    <p>{`Import from library, other parameters`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`import lib-env.glsl\n import lib-emissive.glsl\n import lib-random.glsl\n import lib-vectors.glsl\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-5\"\n      }}>{`#`}</a></p>\n    <p>{`BRDF related functions`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`const float EPSILON_COEF = 1e-4;\n \n float normal_distrib(\n   float ndh,\n   float Roughness)\n {\n   // use GGX / Trowbridge-Reitz, same as Disney and Unreal 4\n   // cf http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf p3\n   float alpha = Roughness * Roughness;\n   float tmp = alpha / max(1e-8,(ndh*ndh*(alpha*alpha-1.0)+1.0));\n   return tmp * tmp * M_INV_PI;\n }\n \n vec3 fresnel(\n   float vdh,\n   vec3 F0)\n {\n   // Schlick with Spherical Gaussian approximation\n   // cf http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf p3\n   float sphg = exp2((-5.55473*vdh - 6.98316) * vdh);\n   return F0 + (vec3(1.0) - F0) * sphg;\n }\n \n vec3 fresnel(\n   float vdh,\n   vec3 F0,\n   vec3 F82)\n {\n   vec3 b = (1.0 - F82) * (F0 * 9.48471792 + 8.16666665);\n   float e = 1.0 - vdh;\n   float e5 = e * e; e5 *= e5 * e;\n   vec3 offset = (1.0 - F0 - b * (vdh * e)) * e5;\n   return clamp(F0 + offset, 0.0, 1.0);\n }\n \n float G1(\n   float ndw, // w is either Ln or Vn\n   float k)\n {\n   // One generic factor of the geometry function divided by ndw\n   // NB : We should have k > 0\n   return 1.0 / ( ndw*(1.0-k) +  k );\n }\n \n float visibility(\n   float ndl,\n   float ndv,\n   float Roughness)\n {\n   // Schlick with Smith-like choice of k\n   // cf http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf p3\n   // visibility is a Cook-Torrance geometry function divided by (n.l)*(n.v)\n   float k = max(Roughness * Roughness * 0.5, 1e-5);\n   return G1(ndl,k)*G1(ndv,k);\n }\n \n vec3 cook_torrance_contrib(\n   float vdh,\n   float ndh,\n   float ndl,\n   float ndv,\n   vec3 F0,\n   vec3 F82,\n   float Roughness)\n {\n   // This is the contribution when using importance sampling with the GGX based\n   // sample distribution. This means ct_contrib = ct_brdf / ggx_probability\n   return fresnel(vdh, F0, F82) * (visibility(ndl, ndv, Roughness) * vdh * ndl / ndh );\n }\n \n vec3 cook_torrance_contrib(\n   float vdh,\n   float ndh,\n   float ndl,\n   float ndv,\n   vec3 Ks,\n   float Roughness)\n {\n   return cook_torrance_contrib(vdh, ndh, ndl, ndv, Ks, vec3(1.0), Roughness);\n }\n \n vec3 uniformSample(vec2 Xi, vec3 T, vec3 B, vec3 N)\n {\n    float cosT = Xi.y;\n    float sinT = sqrt(1.0-cosT*cosT);\n    float phi = 2.0*M_PI*Xi.x;\n    return\n        T * (sinT*cos(phi)) +\n        B * (sinT*sin(phi)) +\n        N *  cosT;\n }\n \n vec3 importanceSampleGGX(vec2 Xi, vec3 T, vec3 B, vec3 N, float roughness)\n {\n   float a = roughness*roughness;\n   float cosT = sqrt((1.0-Xi.y)/(1.0+(a*a-1.0)*Xi.y));\n   float sinT = sqrt(1.0-cosT*cosT);\n   float phi = 2.0*M_PI*Xi.x;\n   return\n     T * (sinT*cos(phi)) +\n     B * (sinT*sin(phi)) +\n     N *  cosT;\n }\n \n float probabilityGGX(float ndh, float vdh, float Roughness)\n {\n   return normal_distrib(ndh, Roughness) * ndh / (4.0*vdh);\n }\n \n float distortion(vec3 Wn)\n {\n   // Computes the inverse of the solid angle of the (differential) pixel in\n   // the cube map pointed at by Wn\n   float sinT = sqrt(1.0-Wn.y*Wn.y);\n   return sinT;\n }\n \n float computeLOD(vec3 Ln, float p)\n {\n   return max(0.0, (maxLod-1.5) - 0.5 * log2(float(nbSamples) * p * distortion(Ln)));\n }\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-6\"\n      }}>{`#`}</a></p>\n    <p>{`Horizon fading trick from `}<a parentName=\"p\" {...{\n        \"href\": \"https://marmosetco.tumblr.com/post/81245981087\"\n      }}>{`https://marmosetco.tumblr.com/post/81245981087`}</a></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`float horizonFading(float ndl, float horizonFade)\n {\n   float horiz = clamp(1.0 + horizonFade * ndl, 0.0, 1.0);\n   return horiz * horiz;\n }\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-7\"\n      }}>{`#`}</a></p>\n    <p>{`Compute the lambertian diffuse radiance to the viewer's eye`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`vec3 pbrComputeDiffuse(vec3 normal, vec3 diffColor)\n {\n   return envIrradiance(normal) * diffColor;\n }\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-8\"\n      }}>{`#`}</a></p>\n    <p>{`Compute the microfacets specular reflection to the viewer's eye`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`vec3 pbrComputeSpecular(\n    LocalVectors vectors,\n    vec3 F0,\n    vec3 F82,\n    float roughness,\n    float occlusion,\n    float bentNormalSpecularAmount)\n {\n   vec3 radiance = vec3(0.0);\n   float ndv = dot(vectors.eye, vectors.normal);\n \n   // Bent normals occlusion\n   float occlusionStart = 0.75 - occlusion;\n   float occlusionEnd = 1.0 - occlusion;\n   vec3 envT =  worldToEnvSpace(vectors.tangent);\n   vec3 envB =  worldToEnvSpace(vectors.bitangent);\n   vec3 envN =  worldToEnvSpace(vectors.normal);\n   vec3 envE =  worldToEnvSpace(vectors.eye);\n   vec3 envVertexNormal = worldToEnvSpace(vectors.vertexNormal);\n   vec3 envBent = worldToEnvSpace(vectors.bent);\n \n   for(int i=0; i<nbSamples; ++i)\n   {\n     vec2 Xi = fibonacci2DDitheredTemporal(i, nbSamples);\n     vec3 Hn = importanceSampleGGX(Xi, envT, envB, envN, roughness);\n     vec3 Ln = -reflect(envE,Hn);\n \n     float fade = horizonFading(dot(envVertexNormal, Ln), horizonFade);\n \n     float specOcclusion = 1.0;\n     if(bentNormalSpecularAmount!=0.0)\n     {\n         float mask = 1.0 - sqrt(1.0 - max(0.0, dot(envBent, Ln)));\n         specOcclusion = smoothstep(occlusionStart, occlusionEnd, mask);\n         specOcclusion = mix(1.0, specOcclusion, bentNormalSpecularAmount);\n     }\n \n     float ndl = dot(envN, Ln);\n     ndl = max( 1e-8, ndl );\n     float vdh = max(1e-8, dot(envE, Hn));\n     float ndh = max(1e-8, dot(envN, Hn));\n     float lodS = roughness < 0.01 ? 0.0 : computeLOD(Ln, probabilityGGX(ndh, vdh, roughness));\n     radiance += fade * specOcclusion * envSample(Ln, lodS) *\n       cook_torrance_contrib(vdh, ndh, ndl, ndv, F0, F82, roughness);\n   }\n   // Remove occlusions on shiny reflections\n   radiance /= float(nbSamples);\n \n   return radiance;\n }\n \n vec3 pbrComputeSpecular(\n    LocalVectors vectors,\n    vec3 F0,\n    vec3 F82,\n    float roughness)\n {\n   return pbrComputeSpecular(vectors, F0, F82, roughness, 1.0, 0.0);\n }\n \n vec3 pbrComputeSpecular(\n    LocalVectors vectors,\n    vec3 specColor,\n    float roughness,\n    float occlusion,\n    float bentNormalSpecularAmount)\n {\n   return pbrComputeSpecular(vectors, specColor, vec3(1.0), roughness, occlusion, bentNormalSpecularAmount);\n }\n \n vec3 pbrComputeSpecular(\n    LocalVectors vectors,\n    vec3 specColor,\n    float roughness)\n {\n   return pbrComputeSpecular(vectors, specColor, roughness, 1.0, 0.0);\n }\n \n \n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","_ref","components","props","_objectWithoutPropertiesLoose","_excluded","mdx","_extends","mdxType","parentName","isMDXComponent"],"sourceRoot":""}