{"version":3,"file":"component---src-pages-api-shaders-vraymtl-metallic-md-3479e2609bb18ce821f2.js","mappings":"oTAMaA,EAAe,CAAC,EACvBC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAUC,GAG/B,IAFDC,EAAUD,EAAVC,WACGC,GAAKC,EAAAA,EAAAA,GAAAH,EAAAI,GAER,OAAOC,EAAAA,EAAAA,KAACR,GAASS,EAAAA,EAAAA,GAAA,GAAKV,EAAiBM,EAAK,CAAED,WAAYA,EAAYM,QAAQ,eAG5EF,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,MACE,GAAM,oCAAkC,qCAE1CA,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,sEACAA,EAAAA,EAAAA,KAAA,YAAKA,EAAAA,EAAAA,KAAA,QAAMG,WAAW,MAClB,UAAa,iBAAe,gsBAwBhCH,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,uCACAA,EAAAA,EAAAA,KAAA,YAAKA,EAAAA,EAAAA,KAAA,QAAMG,WAAW,MAClB,UAAa,iBAAe,wpBA2BhCH,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,sCACAA,EAAAA,EAAAA,KAAA,YAAKA,EAAAA,EAAAA,KAAA,QAAMG,WAAW,MAClB,UAAa,iBAAe,gukCAq9BhCH,EAAAA,EAAAA,KAAA,UAAGA,EAAAA,EAAAA,KAAA,KAAGG,WAAW,IACb,KAAQ,cAAY,OAExBH,EAAAA,EAAAA,KAAA,iCACAA,EAAAA,EAAAA,KAAA,YAAKA,EAAAA,EAAAA,KAAA,QAAMG,WAAW,MAClB,UAAa,iBAAe,wzHA4FpC,CAEAT,EAAWU,gBAAiB,C","sources":["webpack://dev-site-documentation-template/./src/pages/api/shaders/vraymtl-metallic.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/runner/work/painter-shader-api/painter-shader-api/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-0\"\n      }}>{` `}</a></p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-1\"\n      }}>{` `}</a></p>\n    <h1 {...{\n      \"id\": \"substance-painter-vraymtl-shader\"\n    }}>{`Substance Painter VRayMtl shader`}</h1>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-2\"\n      }}>{` `}</a></p>\n    <p>{`Channels needed for metal/rough workflow are bound here.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`//: param auto channel_basecolor\n uniform SamplerSparse basecolor_tex;\n //: param auto channel_roughness\n uniform SamplerSparse roughness_tex;\n //: param auto channel_metallic\n uniform SamplerSparse metallic_tex;\n //: param auto channel_transmissive\n uniform SamplerSparse transmissive_tex;\n //: param auto channel_emissive\n uniform SamplerSparse emissive_tex;\n //: param auto channel_anisotropyangle\n uniform SamplerSparse anisotropyangle_tex;\n //: param auto channel_anisotropylevel\n uniform SamplerSparse anisotropylevel_tex;\n \n import lib-env.glsl\n import lib-random.glsl\n import lib-sampler.glsl\n import lib-utils.glsl\n import lib-vectors.glsl\n \n //: state cull_face off\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-3\"\n      }}>{` `}</a></p>\n    <p>{`Parameters from Substance`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`//: param auto main_light\n uniform vec4 uniform_main_light;\n \n // params from lib-pbr.\n // We don't want to import the entire lib-pbr because it brings lib-emissive\n // and that messes with our self-illumination params\n \n //: param auto environment_max_lod\n uniform float maxLod;\n \n //: param custom {\n //: \"default\": 16,\n //: \"label\": \"Quality\",\n //: \"widget\": \"combobox\",\n //: \"values\": {\n //: \"Very low (4 spp)\": 4,\n //: \"Low (16 spp)\": 16,\n //: \"Medium (32 spp)\": 32,\n //: \"High (64 spp)\": 64,\n //: \"Very high (128 spp)\": 128,\n //: \"Ultra (256 spp)\": 256\n //: },\n //: \"group\": \"Common Parameters\"\n //: }\n uniform int nbSamples;\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-4\"\n      }}>{` `}</a></p>\n    <p>{`VRayMtl specific options`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`// Group basic options\n //: param custom { \"default\": 1, \"label\": \"Base color amount\", \"min\": 0, \"max\": 1, \"group\": \"Base color\" }\n uniform float uniform_diffuse_amount;\n \n // Group reflection\n //: param custom { \"default\": 1, \"label\": \"Reflection amount\", \"min\": 0, \"max\": 1, \"group\": \"Reflection\" }\n uniform float uniform_reflection_amount;\n //: param custom { \"default\": true, \"label\": \"Use fresnel\", \"group\": \"Reflection\", \"description\": \"Make reflection strength dependent on the viewing angle (e.g. glass materials). Depends on IOR.\" }\n uniform bool uniform_use_fresnel;\n //: param custom { \"default\": true, \"label\": \"Lock fresnel IOR to refraction IOR\", \"group\": \"Reflection\", \"description\": \"Use the same IOR as refraction for reflection fresnel.\" }\n uniform bool uniform_lock_fresnel_ior;\n //: param custom { \"default\": 1.6, \"label\": \"Fresnel IOR\", \"group\": \"Reflection\", \"description\": \"Separate fresnel reflection IOR, when not locked to refraction IOR.\" }\n uniform float uniform_fresnel_ior;\n \n // Group refraction\n //: param custom {\n //: \"default\": 1, \"label\": \"Refraction amount\", \"min\": 0, \"max\": 1, \"widget\": \"color\", \"group\": \"Refraction\"\n //: }\n uniform float uniform_refraction_amount;\n //: param custom {\n //: \"default\": 1.6, \"label\": \"IOR\", \"group\": \"Refraction\",\n //: \"description\": \"Index of refraction for refraction effect and fresnel reflections (unless disabled in Reflection options)\"\n //: }\n uniform float uniform_refraction_ior;\n //: param custom { \"default\": 1, \"label\": \"Refraction glossiness\", \"min\": 0, \"max\": 1, \"group\": \"Refraction\", \"description\": \"Separate refraction glossiness\" }\n uniform float uniform_refraction_glossiness;\n \n // Group BRDF\n //: param custom {\n //: \"default\": 3,\n //: \"label\": \"BRDF type\",\n //: \"widget\": \"combobox\",\n //: \"values\": {\n //: \"Phong\": 0,\n //: \"Blinn\": 1,\n //: \"Ward\": 2,\n //: \"GGX\": 3\n //: },\n //: \"group\": \"BRDF\"\n //: }\n uniform int uniform_brdf_type;\n //: param custom { \"default\": 2, \"label\": \"GGX tail falloff\", \"min\": 1, \"max\": 10, \"group\": \"BRDF\" }\n uniform float uniform_gtr_gamma;\n //: param custom {\n //: \"default\": 2,\n //: \"label\": \"Anisotropy axis\",\n //: \"widget\": \"combobox\",\n //: \"values\": {\n //: \"X\": 0,\n //: \"Y\": 1,\n //: \"Z\": 2\n //: },\n //: \"group\": \"BRDF\",\n //: \"description\": \"Base local axis for anisotropic highlight\"\n //: }\n uniform int uniform_anisotropy_axis;\n \n // Group options\n //: param custom {\n //: \"default\": true, \"label\": \"Trace reflections\", \"group\": \"Options\",\n //: \"description\": \"When disabled, reflections are not traced, resulting in only highlights. Also the diffuse color is not dimmed by the reflection color, as would happen normally\"\n //: }\n uniform bool uniform_trace_reflections;\n //: param custom {\n //: \"default\": true, \"label\": \"Trace refractions\", \"group\": \"Options\",\n //: \"description\": \"When disabled, refractions are not traced\"\n //: }\n uniform bool uniform_trace_refractions;\n //: param custom {\n //: \"default\": false, \"label\": \"Double sided\", \"group\": \"Options\",\n //: \"description\": \"When enabled, V-Ray also shades the back-facing surfaces. Otherwise, the lighting for the outer side is always computed. Can be used to achieve a fake translucent effect for thin objects like paper.\"\n //: }\n uniform bool uniform_double_sided;\n \n \n float vraySqr(float x) {\n  return x * x;\n }\n \n // Functions from lib-pbr we need to sample the environment properly {{{\n \n /// Compute the inverse of the solid angle of the differential pixel in the\n /// cube map pointed at by Wn\n /// @param Wn World-space direction\n float distortion(vec3 Wn) {\n  float sinT = sqrt(1.0-Wn.y*Wn.y);\n  return sinT;\n }\n \n /// Get the LOD for sampling the environment\n /// @param Wn World-space normal\n /// @param p Probability of this direction (from sampleBRDF)\n /// @param numSamples Total number of samples\n float computeLOD(vec3 Wn, float p, int numSamples) {\n  if (numSamples < 2) {\n  return 0.0;\n  } else {\n  return max(0.0, maxLod - 1.5 - 0.5 * log2(1.0 + float(numSamples) * p * distortion(Wn)));\n  }\n }\n \n // }}} End functions from lib-pbr\n \n struct VRayMtlInitParams {\n  vec3 Vw;\n  vec3 geomNormal;\n  vec3 diffuseColor;\n  float diffuseAmount;\n  float roughness;\n  vec3 selfIllum;\n  vec3 reflColor;\n  float reflAmount;\n  float reflGloss;\n  bool traceReflections;\n  float metalness;\n  float aniso;\n  float anisoRotation;\n  int anisoAxis;\n  vec3 opacity;\n  vec3 refractionColor;\n  float refractionAmount;\n  float refrGloss;\n  bool traceRefractions;\n  float refractionIOR;\n  bool useFresnel;\n  float fresnelIOR;\n  bool lockFresnelIOR;\n  bool doubleSided;\n  bool useRoughness;\n  float gtrGamma;\n  int brdfType;\n  bool approxEnv;\n };\n \n struct VRayMtlContext {\n  vec3 geomNormal;\n  float gloss1;\n  float gloss2;\n  float reflGloss;\n  vec3 e;\n  vec3 diff;\n  float fresnel;\n  vec3 reflNoFresnel;\n  vec3 refl;\n  vec3 refr;\n  vec3 illum;\n  vec3 opacity;\n  float rtermA;\n  float rtermB;\n  float gtrGamma;\n  float blueNoise; // blue noise value based on fragment\n  mat3 nm;\n  mat3 inm;\n };\n \n float intensity(vec3 v);\n vec3 vraySampleBRDF(VRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, out float brdfContrib);\n vec3 vraySampleRefractBRDF(VRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, out bool totalInternalReflection);\n \n VRayMtlContext initVRayMtlContext(VRayMtlInitParams initParams);\n \n vec3 vrayComputeDirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir);\n vec3 vrayComputeDirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir);\n \n vec3 vrayComputeIndirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx);\n vec3 vrayComputeIndirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx);\n vec3 vrayComputeIndirectRefractionContribution(VRayMtlInitParams params, VRayMtlContext ctx, float alpha, vec3 alphaDir, vec3 diffuseIndirect);\n \n int debugOutput = 0;\n \n // Output v as colour, suppress normal shading\n void vrayDebug(vec3 v) {\n  debugOutput = 1;\n  albedoOutput(v);\n  diffuseShadingOutput(vec3(1.0));\n }\n \n // Output f as grey colour, suppress normal shading\n void vrayDebug(float f) {\n  vrayDebug(vec3(f));\n }\n \n #define PI 3.1415926535897932384626433832795\n #define INV_PI (1.0/PI)\n \n vec3 vrayWhiteComplement(vec3 x) {\n  return clamp(1.0 - x, 0.0, 1.0);\n }\n \n void vrayComputeTangentVectors(vec3 n, out vec3 u, out vec3 v) {\n  // It doesn't matter what these vectors are, the result vectors just need to be perpendicular to the normal and to each other\n  u = cross(n, vec3(0.643782, 0.98432, 0.324632));\n  if (length(u) < 1e-6)\n  u = cross(n, vec3(0.432902, 0.43223, 0.908953));\n  u = normalize(u);\n  v = normalize(cross(n, u));\n }\n \n void vrayMakeNormalMatrix(in vec3 n, out mat3 m) {\n  vrayComputeTangentVectors(n, m[0], m[1]);\n  m[2] = n;\n }\n \n float vrayGetFresnelCoeff(float fresnelIOR, vec3 e, vec3 n, vec3 refractDir) {\n  if (abs(fresnelIOR - 1.0) < 1e-6)\n  return 0.0;\n \n  float cosIn = -dot(e, n);\n  float cosR = -dot(refractDir, n);\n \n  if (cosIn > 1.0 - 1e-12 || cosR > 1.0 - 1e-12) { // View direction is perpendicular to the surface\n  float f = (fresnelIOR - 1.0) / (fresnelIOR + 1.0);\n  return f * f;\n  }\n \n  float ks = (cosR / cosIn) * fresnelIOR;\n  float fs2 = (ks - 1.0) / (ks + 1.0);\n  float Fs = fs2 * fs2;\n \n  float kp = (cosIn / cosR) * fresnelIOR;\n  float fp2 = (kp - 1.0) / (kp + 1.0);\n  float Fp = fp2 * fp2;\n \n  return 0.5 * (Fs + Fp);\n }\n \n vec3 vrayGetSpecularDir(float u, float v, float k) {\n  float thetaSin = clamp(pow(u, 1.0 / (k + 1.0)), 0.0, 1.0);\n  float thetaCos = sqrt(1.0 - thetaSin * thetaSin);\n  float phi = 2.0 * PI * v;\n  return vec3(cos(phi) * thetaCos, sin(phi) * thetaCos, thetaSin);\n }\n \n vec3 vrayGetPhongDir(float uc, float vc, float glossiness, vec3 view, mat3 nm) {\n  vec3 reflectDir = reflect(-view, nm[2]);\n  vec3 s = cross(vec3(0, 1, 0), reflectDir);\n  vec3 s1 = cross(reflectDir, s);\n  mat3 m;\n  m[0] = normalize(s);\n  m[1] = normalize(s1);\n  m[2] = normalize(reflectDir);\n  vec3 sampleDir = vrayGetSpecularDir(uc, vc, glossiness);\n  return m * sampleDir;\n }\n \n vec3 vrayGetBlinnDir(float uc, float vc, float glossiness, vec3 view, mat3 nm) {\n  vec3 nn = vrayGetSpecularDir(uc, vc, glossiness);\n  vec3 h = normalize(nm * nn);\n  float cs = 2.0 * dot(h, view);\n  vec3 dir = normalize(-view + cs * h);\n  return dir;\n }\n \n vec3 vrayGetSphereDir(float u, float v) {\n  float thetaSin = u;\n  float thetaCos = sqrt(1.0 - thetaSin * thetaSin);\n  float phi = 2.0 * PI * v;\n  return vec3(cos(phi) * thetaCos, sin(phi) * thetaCos, thetaSin);\n }\n \n vec3 vrayGetWardDir(float u, float v, float glossiness, vec3 view, mat3 nm) {\n  if (u >= 1.0)\n  u -= 1.0;\n \n  float k = -log(1.0 - u);\n  if (k < 0.0)\n  k = 0.0;\n \n  float thetaCos = sqrt(1.0 / (glossiness * k + 1.0));\n  vec3 hn = vrayGetSphereDir(thetaCos, v);\n  vec3 hw = normalize(nm * hn);\n  vec3 dir = reflect(-view, hw);\n  return dir;\n }\n \n vec3 vrayGetGTR1MicroNormal(float uc, float vc, float sharpness) {\n  float sharpness2 = min(sharpness * sharpness, 0.999);\n  float thetaCosSqr = (1.0 - pow(sharpness2, 1.0 - uc)) / (1.0 - sharpness2);\n  float thetaCos = sqrt(thetaCosSqr);\n  float thetaSin = sqrt(max(1.0 - thetaCosSqr, 0.0));\n \n  float phi = 2.0 * PI * vc;\n  return vec3(cos(phi) * thetaSin, sin(phi) * thetaSin, thetaCos);\n }\n \n // Specific implementation when gamma == 2. See section B.2 Physically-Based Shading at Disney from SIGGRAPH 2012\n vec3 vrayGetGTR2MicroNormal(float uc, float vc, float sharpness) {\n  //vrayDebug(sharpness);\n  float thetaCosSqr = (1.0 - uc) / (1.0 + (sharpness * sharpness - 1.0) * uc);\n  float thetaCos = sqrt(thetaCosSqr);\n  float thetaSin = sqrt(max(1.0 - thetaCosSqr, 0.0));\n \n  float phi = 2.0 * PI * vc;\n  return vec3(cos(phi) * thetaSin, sin(phi) * thetaSin, thetaCos);\n }\n \n // // General implementation when gamma != 1 and != 2. See section B.2 Physically-Based Shading at Disney from SIGGRAPH 2012\n vec3 vrayGetGTRMicroNormal(float uc, float vc, float sharpness, float gtrGamma) {\n  float sharpness2 = min(sharpness * sharpness, 0.999);\n  float thetaCosSqr = (1.0 - pow(pow(sharpness2, 1.0 - gtrGamma) * (1.0 - uc) + uc, 1.0 / (1.0 - gtrGamma))) / (1.0 - sharpness2);\n  float thetaCos = sqrt(thetaCosSqr);\n  float thetaSin = sqrt(max(1.0 - thetaCosSqr, 0.0));\n \n  float phi = 2.0 * PI * vc;\n  return vec3(cos(phi) * thetaSin, sin(phi) * thetaSin, thetaCos);\n }\n \n vec3 vrayGetGGXMicroNormal(float uc, float vc, float sharpness, float gtrGamma) {\n  if (abs(gtrGamma - 1.0) < 1e-3)\n  return vrayGetGTR1MicroNormal(uc, vc, sharpness);\n  else if (abs(gtrGamma - 2.0) < 1e-3)\n  return vrayGetGTR2MicroNormal(uc, vc, sharpness);\n  else // if (gtrLowerLimit <= gtrGamma && gtrGamma <= gtrUpperLimit)\n  return vrayGetGTRMicroNormal(uc, vc, sharpness, gtrGamma);\n }\n \n float vrayGetGTR1MicrofacetDistribution(float mz, float sharpness) {\n  float cosThetaM = mz; // dotf(microNormal, normal);\n  if (cosThetaM <= 1e-3)\n  return 0.0;\n \n  float cosThetaM2 = vraySqr(cosThetaM);\n  float tanThetaM2 = (1.0 / cosThetaM2) - 1.0;\n  float sharpness2 = vraySqr(sharpness);\n  float div = PI * log(sharpness2) * cosThetaM2 * (sharpness2 + tanThetaM2);\n  // when div<(sharpness2-1.0f)*1e-6f no division by zero will occur (the dividend and the divisor are always negative);\n  // div can get 0 in rare situation when the sharpness read from texture mapped in reflection glossines is 0\n  // and cosThetaM is 1 (and consequently tanThetaM2 is 0);\n  float res = (div < (sharpness2 - 1.0) * 1e-6) ? (sharpness2 - 1.0) / div : 0.0;\n \n  return res;\n }\n \n float vrayGetGTR2MicrofacetDistribution(float mz, float sharpness) {\n  float cosThetaM = mz; // dotf(microNormal, normal);\n  if (cosThetaM <= 1e-3f)\n  return 0.0f;\n \n  float cosThetaM2 = vraySqr(cosThetaM);\n  float tanThetaM2 = (1.0 / cosThetaM2) - 1.0;\n  float sharpness2 = vraySqr(sharpness);\n  float div = PI * vraySqr(cosThetaM2 * (sharpness2 + tanThetaM2));\n  // when div>sharpness2*1e-6f no division by zero will occur (the dividend and the divisor are always positive);\n  // div canget0 in rare situation when the sharpness read from texture mapped in reflection glossines is 0\n  // and cosThetaM is 1 (and consequently tanThetaM2 is 0);\n  float res = (div > sharpness2 * 1e-6) ? sharpness2 / div : 0.0;\n \n  return res;\n }\n \n float vrayGetGTRMicrofacetDistribution(float mz, float sharpness, float gtrGamma) {\n  float cosThetaM = mz; // dotf(microNormal, normal);\n  if (cosThetaM <= 1e-3)\n  return 0.0;\n \n  float cosThetaM2 = vraySqr(cosThetaM);\n  float tanThetaM2 = (1.0 / cosThetaM2) - 1.0;\n  float sharpness2 = vraySqr(sharpness);\n  float divisor = PI * (1.0 - pow(sharpness2, 1.0 - gtrGamma)) * pow(cosThetaM2 * (sharpness2 + tanThetaM2), gtrGamma);\n  float dividend = (gtrGamma - 1.0) * (sharpness2 - 1.0);\n  // when fabsf(divisor)>fabsf(dividend)*1e-6f no division by zero will occur\n  // (the dividend and the divisor are always either both positive or both negative);\n  // divisor canget0 in rare situation when the sharpness read from texture mapped in reflection glossines is 0\n  // and cosThetaM is 1 (and consequently tanThetaM2 is 0);\n  float res = (abs(divisor) > abs(dividend) * 1e-6) ? dividend / divisor : 0.0;\n \n  return res;\n }\n \n float vrayGetGGXMicrofacetDistribution(float cosNH, float sharpness, float gtrGamma) {\n  if (abs(gtrGamma - 1.0) < 1e-3)\n  return vrayGetGTR1MicrofacetDistribution(cosNH, sharpness);\n  else if (abs(gtrGamma - 2.0) < 1e-3)\n  return vrayGetGTR2MicrofacetDistribution(cosNH, sharpness);\n  else // if (gtrLowerLimit <= gtrGamma && gtrGamma <= gtrUpperLimit)\n  return vrayGetGTRMicrofacetDistribution(cosNH, sharpness, gtrGamma);\n }\n \n float vrayGetGTRMonodirectionalShadowing0(float cotThetaV) {\n  return 2.0 / (1.0 + sqrt(1.0 + 1.0 / (cotThetaV * cotThetaV)));\n }\n \n float vrayGetGTRMonodirectionalShadowing1(float sharpness, float cotThetaV) {\n  float cotThetaV2 = vraySqr(cotThetaV);\n  float sharpness2 = min(0.999, vraySqr(sharpness));\n  float a = sqrt(cotThetaV2 + sharpness2);\n  float b = sqrt(cotThetaV2 + 1.0);\n  return cotThetaV * log(sharpness2) / (a - b + cotThetaV * log(sharpness2 * (cotThetaV + b) / (cotThetaV + a)));\n }\n \n float vrayGetGTRMonodirectionalShadowing2(float sharpness, float cotThetaV) {\n  return 2.0 / (1.0 + sqrt(1.0 + vraySqr(sharpness / cotThetaV)));\n }\n \n float vrayGetGTRMonodirectionalShadowing3(float sharpness, float cotThetaV) {\n  float cotThetaV2 = vraySqr(cotThetaV);\n  float sharpness2 = min(0.999, vraySqr(sharpness));\n  float a = sqrt(cotThetaV2 + sharpness2);\n  float b = sharpness2 + 1.0;\n  return 4.0 * cotThetaV * a * b / (2.0 * cotThetaV * b * (cotThetaV + a) + sharpness2 * (3.0 * sharpness2 + 1.0));\n }\n \n float vrayGetGTRMonodirectionalShadowing4(float sharpness, float cotThetaV) {\n  float cotThetaV2 = cotThetaV * cotThetaV;\n  float sharpness2 = min(0.999, vraySqr(sharpness));\n  float sharpness4 = sharpness2 * sharpness2;\n  float a = 8.0 * (sharpness4 + sharpness2 + 1.0);\n  float b = sqrt(cotThetaV2 + sharpness2);\n  float b3 = b * (cotThetaV2 + sharpness2);\n  return 2.0 * cotThetaV * a * b3 / (a * cotThetaV * (b3 + cotThetaV * cotThetaV2) + 3.0 * sharpness2 * (4.0 * cotThetaV2 * (2.0 * sharpness4 + sharpness2 + 1.0) + sharpness2 * (5.0 * sharpness4 + 2.0 * sharpness2 + 1.0)));\n }\n \n float vrayGetGTRMonodirectionalShadowingSpline(float gtrGamma, float sharpness, float cotThetaV) {\n  const int numKnots = 5;\n \n  float knots[numKnots];\n  knots[0] = vrayGetGTRMonodirectionalShadowing0(cotThetaV);\n  knots[1] = vrayGetGTRMonodirectionalShadowing1(sharpness, cotThetaV);\n  knots[2] = vrayGetGTRMonodirectionalShadowing2(sharpness, cotThetaV);\n  knots[3] = vrayGetGTRMonodirectionalShadowing3(sharpness, cotThetaV);\n  knots[4] = vrayGetGTRMonodirectionalShadowing4(sharpness, cotThetaV);\n \n  float m[numKnots];\n  float c[numKnots];\n  for (int i = 1; i < numKnots - 1; i++) {\n  m[i] = 4.0;\n  c[i - 1] = 6.0 * (knots[i + 1] - 2.0 * knots[i] + knots[i - 1]);\n  }\n \n  // solve tridiagonal\n  for (int i = 1; i < numKnots - 2; i++) {\n  float x = 1.0 / m[i];\n  m[i + 1] -= x;\n  c[i] -= x * c[i - 1];\n  }\n \n  m[numKnots - 2] = c[numKnots - 3] / m[numKnots - 2];\n \n  for (int i = numKnots - 4; i >= 0; i--) {\n  m[i + 1] = (c[i] - m[i + 2]) / m[i + 1];\n  }\n \n  m[0] = 0.0;\n  m[numKnots - 1] = 0.0;\n \n  // contstruct polynomials\n  vec4 polys[numKnots - 1];\n  for (int i = 0; i < numKnots - 1; i++) {\n  polys[i].x = (m[i + 1] - m[i]) / 6.0;\n  polys[i].y = 0.5 * m[i];\n  polys[i].z = (knots[i + 1] - knots[i]) - (2.0 * m[i] + m[i + 1]) / 6.0;\n  polys[i].w = knots[i];\n  }\n \n  // eval\n  float gamma = clamp(gtrGamma, 0.0, 4.0);\n  int idx = int(floor(gtrGamma));\n  float x = gtrGamma - float(idx);\n  float v = ((polys[idx].x * x + polys[idx].y) * x + polys[idx].z) * x + polys[idx].w;\n  return v;\n }\n \n float vrayGetGGXMonodirectionalShadowing(vec3 dir, vec3 hw, vec3 normal, float sharpness, float gtrGamma) {\n  float cosThetaV = dot(dir, normal);\n \n  if (cosThetaV <= 1e-3)\n  return 0.0;\n \n  if (dot(dir, hw) * cosThetaV <= 0.0) // Note: technically this is a division, but since we are only interested in the sign, we can do multiplication\n  return 0.0;\n \n  // when direction is collinear to the normal there is no shadowing\n  // moreover if this case is not handled a division by zero will happen on the next line\n  if (cosThetaV >= 1.0 - 1e-6)\n  return 1.0;\n \n  float cotThetaV = cosThetaV / sqrt(1.0 - vraySqr(cosThetaV));\n \n  float res = 0.0;\n \n  // when gamma is any of the integer values 0, 1, 2, 3, 4 apply analytical solution\n  if (gtrGamma <= 0.01)\n  res = vrayGetGTRMonodirectionalShadowing0(cotThetaV);\n  else if (abs(gtrGamma - 1.0) <= 1e-2)\n  res = vrayGetGTRMonodirectionalShadowing1(sharpness, cotThetaV);\n  else if (abs(gtrGamma - 2.0) <= 1e-2)\n  res = vrayGetGTRMonodirectionalShadowing2(sharpness, cotThetaV);\n  else if (abs(gtrGamma - 3.0) <= 1e-2)\n  res = vrayGetGTRMonodirectionalShadowing3(sharpness, cotThetaV);\n  else if (gtrGamma >= 4.0 - 1e-2)\n  res = vrayGetGTRMonodirectionalShadowing4(sharpness, cotThetaV);\n  else {\n  // gamma is not an integer. interpolate\n  res = vrayGetGTRMonodirectionalShadowingSpline(gtrGamma, sharpness, cotThetaV);\n  }\n \n  return clamp(res, 0.0, 1.0);\n }\n \n float vrayGetGGXBidirectionalShadowingMasking(vec3 view, vec3 dir, vec3 hw, vec3 normal, float sharpness, float gtrGamma) {\n  return vrayGetGGXMonodirectionalShadowing(view, hw, normal, sharpness, gtrGamma) * vrayGetGGXMonodirectionalShadowing(dir, hw, normal, sharpness, gtrGamma);\n }\n \n float vrayGetGGXContribution(vec3 view, vec3 dir, vec3 hw, vec3 hl, float sharpness, float gtrGamma, vec3 normal, out float partialProb, out float D) {\n  float cosIN = abs(dot(view, normal));\n  float cosON = abs(dot(dir, normal));\n \n  if (cosIN <= 1e-6 || cosON <= 1e-6)\n  return 0.0;\n \n  float partialBrdf = 0.0;\n \n  float hn = hl.z;\n  D = vrayGetGGXMicrofacetDistribution(hn, sharpness, gtrGamma);\n  partialBrdf = 0.25 * vrayGetGGXBidirectionalShadowingMasking(view, dir, hw, normal, sharpness, gtrGamma) / cosIN; // division by cosON is omitted because we would have to multiply by the same below;\n \n  if (hn > 0.0) {\n  partialProb = hn;\n \n  float ho = dot(hw, dir);\n  partialProb *= ho > 0.0 ? 0.25 / ho : 0.0;\n  }\n \n  // reduce some multiplications in the final version\n  // partialBrdf *= cosON; - omitted\n \n  return partialBrdf;\n }\n \n vec3 vrayGetGGXDir(float u, float v, float sharpness, float gtrGamma, vec3 view, mat3 nm, out float prob, out float brdfDivByProb) {\n  vec3 microNormalLocal = vrayGetGGXMicroNormal(u, v, sharpness, gtrGamma);\n  //vrayDebug(microNormalLocal * 0.5 + vec3(0.5));\n  if (microNormalLocal.z < 0.0)\n  return nm[2];\n \n  vec3 microNormal = nm * microNormalLocal;\n \n  // Compute and keep the length of the half-vector in local space; needed for anisotropy correction\n  float L2 = dot(microNormal, microNormal);\n  float L = sqrt(L2);\n  microNormal /= L;\n \n  vec3 dir = reflect(-view, microNormal);\n \n  float Dval = 0.0;\n  float partialProb = 0.0;\n  float partialBrdf = vrayGetGGXContribution(view, dir, microNormal, microNormalLocal, sharpness, gtrGamma, nm[2], partialProb, Dval);\n  partialProb *= L * L2; // take anisotropy in consideration\n  prob = (Dval >= 1e-6) ? partialProb * Dval : 1e18; // compute full probability\n  // note: in the full VRayMtl prob is multiplied by 2PI, but in this shader\n  // it's used exclusively to sample tne environment map, and we would have\n  // to divide by 2PI in that computation.\n  brdfDivByProb = (partialProb >= 1e-6) ? partialBrdf / partialProb : 0.0;\n  return dir;\n }\n \n float vrayRand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n }\n \n /// Generate a random vec2, u in (0, 1), v in (B, B+1) where B is a fragment-dependent random blue noise value.\n /// The returned value is suitable to be used for sampling a specular BRDF. V is\n /// offset using blue noise, so it can be above 1, but that should be OK because\n /// it is expected to be used as the argument to a trigonometric function.\n vec2 uvRand(VRayMtlContext ctx, int sampleIdx) {\n  // plastic constant\n  // gives slightly better result than golden ratio\n  float plast = 1.324717957244746;\n  float invPlast = 1.0/plast;\n  return vec2(\n  fract(float(sampleIdx + 1) * invPlast),\n  float(sampleIdx) / float(nbSamples) + ctx.blueNoise\n  );\n }\n \n \n float intensity(vec3 v) {\n  return (v.x + v.y + v.z) / 3.0;\n }\n \n vec3 vraySampleBRDF(VRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, out float rayProb, out float brdfContrib) {\n  vec3 geomNormal = params.geomNormal;\n  int brdfType = params.brdfType;\n  vec2 uv = uvRand(ctx, sampleIdx);\n  float u = uv.x;\n  float v = uv.y;\n \n  vec3 dir = vec3(0.0);\n  rayProb = 1.0;\n  brdfContrib = 1.0;\n \n  if (brdfType==0) { // Phong\n  dir = vrayGetPhongDir(u, v, ctx.gloss1, -ctx.e, ctx.nm);\n  }\n  else if (brdfType==1) { // Blinn\n  dir = vrayGetBlinnDir(u, v, ctx.gloss1, -ctx.e, ctx.nm);\n  }\n  else if (brdfType==2) { // Ward\n  dir = vrayGetWardDir(u, v, ctx.gloss2, -ctx.e, ctx.nm);\n  }\n  else {\n  dir = vrayGetGGXDir(u, v, ctx.gloss2, ctx.gtrGamma, -ctx.e, ctx.nm, rayProb, brdfContrib);\n  }\n \n  if (dot(dir, geomNormal) < 0.0f) {\n  brdfContrib = 0.0;\n  }\n  return dir;\n }\n \n vec3 vraySampleRefractBRDF(VRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, out bool totalInternalReflection) {\n  vec3 geomNormal = params.geomNormal;\n  vec3 refractDir = refract(ctx.e, geomNormal, 1.0 / params.refractionIOR);\n  totalInternalReflection = false;\n  if (refractDir == vec3(0.0)) {\n  refractDir = reflect(ctx.e, geomNormal);\n  totalInternalReflection = true;\n  }\n \n  vec3 s = cross(vec3(0, 1, 0), refractDir);\n  vec3 s1 = cross(refractDir, s);\n  mat3 m;\n  m[0] = normalize(s);\n  m[1] = normalize(s1);\n  m[2] = normalize(refractDir);\n \n  vec2 uv = uvRand(ctx, sampleIdx);\n  float u = uv.x;\n  float v = uv.y;\n  float gloss = 1.0 / pow(max(1.0 - params.refrGloss, 1e-4), 3.5) - 1.0;\n  vec3 sampleDir = vrayGetSpecularDir(u, v, gloss);\n \n  return m * sampleDir;\n }\n \n float pow35(float x) {\n  return x * x * x * sqrt(x);\n }\n \n VRayMtlContext initVRayMtlContext(VRayMtlInitParams initParams) {\n  float reflGloss = initParams.reflGloss;\n  vec3 Vw = initParams.Vw;\n  vec3 geomNormal = initParams.geomNormal;\n  vec3 selfIllum = initParams.selfIllum;\n  vec3 diffuseColor = initParams.diffuseColor;\n  float diffuseAmount = initParams.diffuseAmount;\n  vec3 reflColor = initParams.reflColor;\n  float reflAmount = initParams.reflAmount;\n  bool traceReflections = initParams.traceReflections;\n  float metalness = initParams.metalness;\n  float aniso = initParams.aniso;\n  float anisoRotation = initParams.anisoRotation;\n  int anisoAxis = initParams.anisoAxis;\n  vec3 opacity = initParams.opacity;\n  float roughness = initParams.roughness;\n  vec3 refractionColor = initParams.refractionColor;\n  float refractionAmount = initParams.refractionAmount;\n  bool traceRefractions = initParams.traceRefractions;\n  float refractionIOR = initParams.refractionIOR;\n  bool useFresnel = initParams.useFresnel;\n  float fresnelIOR = initParams.fresnelIOR;\n  bool lockFresnelIOR = initParams.lockFresnelIOR;\n  bool doubleSided = initParams.doubleSided;\n  bool useRoughness = initParams.useRoughness;\n  float gtrGamma = initParams.gtrGamma;\n  int brdfType = initParams.brdfType;\n \n  VRayMtlContext result;\n  if (initParams.lockFresnelIOR)\n  fresnelIOR = initParams.refractionIOR;\n \n  result.e = -normalize(Vw);\n  if (useRoughness)\n  reflGloss = 1.0 - reflGloss; // Invert glossiness (turn it into roughness)\n \n  result.reflGloss = reflGloss;\n  result.opacity = opacity;\n  result.diff = diffuseColor * diffuseAmount * result.opacity;\n  result.illum = selfIllum * result.opacity;\n  // roughness\n  float sqrRough = roughness * roughness;\n  result.rtermA = 1.0 - 0.5 * (sqrRough / (sqrRough + 0.33));\n  result.rtermB = 0.45 * (sqrRough / (sqrRough + 0.09));\n \n  if (doubleSided && dot(geomNormal, result.e) > 0.0)\n  geomNormal = -geomNormal;\n \n  vec3 reflectDir = reflect(result.e, geomNormal);\n  result.geomNormal = geomNormal;\n \n  // check for internal reflection\n  bool internalReflection;\n  vec3 refractDir;\n  bool outToIn = (dot(geomNormal, result.e) < 0.0);\n  float ior = (outToIn ? 1.0 / refractionIOR : refractionIOR);\n  vec3 normal = (outToIn ? geomNormal : -geomNormal);\n \n  float cost = -dot(result.e, normal);\n  float sintSqr = 1.0 - ior * ior * (1.0 - cost * cost);\n  if (sintSqr > 1e-6) {\n  internalReflection = false;\n  refractDir = ior * result.e + (ior * cost - sqrt(sintSqr)) * normal;\n  } else {\n  internalReflection = true;\n  refractDir = reflectDir;\n  }\n  result.fresnel = 1.0;\n  if (useFresnel && !internalReflection)\n  result.fresnel = clamp(vrayGetFresnelCoeff(fresnelIOR, result.e, normal, refractDir), 0.0, 1.0);\n  //vrayDebug(result.fresnel);\n \n  result.reflNoFresnel = reflColor * reflAmount * result.opacity;\n  result.refl = result.reflNoFresnel * result.fresnel;\n \n  // Reflection calculation including metalness. Taken from VRayMtl's original implementation.\n  vec3 metalColor = result.diff * result.fresnel * metalness;\n \n  vec3 dielectricReflectionTransparency = traceReflections ? (1.0 - result.refl) : vec3(1.0);\n  vec3 reflectionTransparency = (1.0 - metalness) * dielectricReflectionTransparency;\n  if (traceRefractions) {\n  result.refr = refractionColor * refractionAmount * result.opacity * reflectionTransparency;\n  } else {\n  result.refr = vec3(0.0);\n  }\n  result.diff *= reflectionTransparency - result.refr;\n \n  result.refl = mix(metalColor, result.refl, result.fresnel);\n  if (result.fresnel > 1e-6) {\n  result.refl /= result.fresnel;\n  }\n \n  result.gloss1 = max(0.0, 1.0 / pow35(max(1.0 - reflGloss, 1e-4)) - 1.0); // [0, 1] -> [0, inf)\n  result.gloss2 = max(1.0 - reflGloss, 1e-4);\n  result.gloss2 *= result.gloss2;\n  result.gtrGamma = gtrGamma;\n  result.blueNoise = getBlueNoiseThresholdTemporal();\n \n  // Set up the normal/inverse normal matrices for BRDFs that support anisotropy\n  vec3 anisoDirection = vec3(0.0, 0.0, 1.0);\n  if (anisoAxis == 0)\n  anisoDirection = vec3(1.0, 0.0, 0.0);\n  else if (anisoAxis == 1)\n  anisoDirection = vec3(0.0, 1.0, 0.0);\n  float anisoAbs = abs(aniso);\n  if (anisoAbs < 1e-12 || anisoAbs >= 1.0 - 1e-6) {\n  vrayMakeNormalMatrix(geomNormal, result.nm);\n  result.inm = transpose(result.nm); // inverse = transpose for orthogonal matrix\n  } else if (!internalReflection) {\n  vec3 base0, base1;\n  base0 = normalize(cross(geomNormal, anisoDirection));\n  base1 = normalize(cross(base0, geomNormal));\n  float anisor = anisoRotation * 6.2831853;\n  if (abs(anisor) > 1e-6) {\n  float cs = cos(anisor);\n  float sn = sin(anisor);\n  vec3 nu = base0 * cs - base1 * sn;\n  vec3 nv = base0 * sn + base1 * cs;\n  base0 = nu;\n  base1 = nv;\n  }\n \n  if (length(cross(base0, base1)) < 1e-6)\n  vrayComputeTangentVectors(geomNormal, base0, base1);\n  if (aniso > 0.0) {\n  float a = 1.0 / (1.0 - aniso);\n  base0 *= a;\n  base1 /= a;\n  } else {\n  float a = 1.0 / (1.0 + aniso);\n  base0 /= a;\n  base1 *= a;\n  }\n  result.nm[0] = base0;\n  result.nm[1] = base1;\n  result.nm[2] = geomNormal;\n  result.inm = inverse(result.nm);\n  }\n \n  return result;\n }\n \n vec3 vrayMtlDiffuse(vec3 lightDir, vec3 normal) {\n  return vec3(max(0.0, dot(lightDir, normal)));\n }\n \n vec3 vrayMtlDiffuseRoughness(vec3 lightDir, VRayMtlContext ctx) {\n  float lightNdotL = max(0.0, dot(lightDir, ctx.geomNormal));\n  float rmult = 1.0;\n  vec3 vecV = -ctx.e;\n  float NV = clamp(dot(ctx.geomNormal, vecV), 0.0, 1.0);\n  float theta_i = acos(lightNdotL);\n  float theta_r = acos(NV);\n  float alpha = max(theta_i, theta_r);\n  if (alpha > 1.571) { // 1.571==pi/2\n  rmult = 0.0;\n  } else {\n  float beta = min(theta_i, theta_r);\n  vec3 vecVtan = vecV - ctx.geomNormal * NV;\n  vec3 vecLtan = lightDir - ctx.geomNormal * lightNdotL;\n  float fMult = length(vecVtan) * length(vecLtan);\n  float cosDeltaPhi = fMult < 0.000001 ? 1.0 : dot(vecVtan, vecLtan) / fMult;\n  rmult = (ctx.rtermA + ctx.rtermB * sin(alpha) * tan(beta) * max(0.0, cosDeltaPhi));\n  }\n  return vec3(lightNdotL * rmult);\n }\n \n vec3 vrayMtlBlinn(vec3 lightDir, VRayMtlContext ctx) {\n  float k = max(0.0, ctx.gloss1);\n  vec3 hw = lightDir - ctx.e;\n  vec3 hn = normalize(ctx.inm * hw);\n  float cs1 = hn.z;\n  if (cs1 > 1e-6) {\n  float lightNdotL = dot(ctx.geomNormal, lightDir);\n  if (cs1 > 1.0)\n  cs1 = 1.0;\n  float cs = -dot(normalize(hw), ctx.e);\n  k = cs < 1e-6 ? 0.0 : pow(cs1, k) * (k + 1.0) * 0.125 / cs;\n  k *= lightNdotL;\n  if (k > 0.0)\n  return vec3(k);\n  }\n  return vec3(0.0);\n }\n \n vec3 vrayMtlPhong(vec3 lightDir, VRayMtlContext ctx) {\n  vec3 reflectDir = reflect(ctx.e, ctx.geomNormal);\n  float cs1 = dot(lightDir, reflectDir);\n  if (cs1 > 0.0) {\n  float lightNdotL = dot(ctx.geomNormal, lightDir);\n  if (cs1 > 1.0)\n  cs1 = 1.0;\n  float k = pow(cs1, ctx.gloss1) * (ctx.gloss1 + 1.0) * 0.5; // phong k\n  k *= lightNdotL;\n  if (k > 0.0)\n  return vec3(k);\n  }\n  return vec3(0.0);\n }\n \n vec3 vrayMtlWard(vec3 lightDir, VRayMtlContext ctx) {\n  float cs1 = -dot(ctx.e, ctx.geomNormal);\n  float lightNdotL = dot(ctx.geomNormal, lightDir);\n  if (lightNdotL > 1e-6 && cs1 > 1e-6) {\n  vec3 hw = lightDir - ctx.e;\n  vec3 hn = normalize(ctx.inm * hw);\n  if (hn.z > 1e-3) {\n  float tanhSqr = (1.0 / (hn.z * hn.z) - 1.0);\n  float divd = cs1 * ctx.gloss2;\n  float k = exp(-tanhSqr / ctx.gloss2) / divd;\n  k *= lightNdotL;\n  if (k > 0.0)\n  return vec3(k);\n  }\n  }\n  return vec3(0.0);\n }\n \n vec3 vrayMtlGGX(vec3 lightDir, VRayMtlContext ctx) {\n  float cs1 = -dot(ctx.e, ctx.geomNormal);\n  float lightNdotL = dot(ctx.geomNormal, lightDir);\n  if (lightNdotL > 1e-6 && cs1 > 1e-6) {\n  vec3 hw = normalize(lightDir - ctx.e);\n  vec3 hn = normalize(ctx.inm * hw);\n  if (hn.z > 1e-3) {\n  float D = vrayGetGGXMicrofacetDistribution(hn.z, ctx.gloss2, ctx.gtrGamma);\n  float G = vrayGetGGXBidirectionalShadowingMasking(-ctx.e, lightDir, hw, ctx.geomNormal, ctx.gloss2, ctx.gtrGamma);\n  float cs2 = max(dot(hw, lightDir), 0.0001);\n  vec3 micron = ctx.nm * hn;\n  float L2 = dot(micron, micron);\n  float anisotropyCorrection = L2 * sqrt(L2);\n  float k = 0.25 * D * G * anisotropyCorrection / cs1; // anisotropy correction\n  if (k > 0.0)\n  return vec3(k);\n  }\n  }\n  return vec3(0.0);\n }\n \n vec3 vrayComputeDirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir) {\n  vec3 res = vec3(0.0);\n  if (params.roughness < 1e-6f) {\n  res = vrayMtlDiffuse(lightDir, ctx.geomNormal);\n  } else {\n  res = vrayMtlDiffuseRoughness(lightDir, ctx);\n  }\n \n  return res;\n }\n \n vec3 vrayComputeDirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir) {\n  vec3 res = vec3(0.0);\n \n  if (params.brdfType==0) {\n  res = vrayMtlPhong(lightDir, ctx);\n  }\n  else if (params.brdfType==1) {\n  res = vrayMtlBlinn(lightDir, ctx);\n  }\n  else if (params.brdfType==2) {\n  res = vrayMtlWard(lightDir, ctx);\n  }\n  else if (params.brdfType==3) {\n  res = vrayMtlGGX(lightDir, ctx);\n  }\n \n  return res;\n }\n \n vec3 vrayComputeIndirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx) {\n  vec3 res = vec3(0.0);\n  res = envIrradiance(params.geomNormal);\n  return res;\n }\n \n vec3 vrayComputeIndirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx) {\n  vec3 res = vec3(0.0);\n \n  if (!params.traceReflections)\n  return res;\n \n  float invNumSamples = 1.0f / float(nbSamples);\n  vec3 envSum = vec3(0.0);\n  for (int i = 0; i < nbSamples; ++i) {\n  float brdfContrib = 0.0f;\n  float rayProb = 0.0f;\n  vec3 dir = vraySampleBRDF(params, ctx, i, rayProb, brdfContrib);\n  if (brdfContrib < 1e-6f)\n  continue;\n  float lod = computeLOD(dir, rayProb, nbSamples);\n  envSum += envSampleLOD(dir, lod) * brdfContrib;\n  }\n  res += envSum * invNumSamples;\n \n  return res;\n }\n \n vec3 vrayComputeIndirectRefractionContribution(VRayMtlInitParams params, VRayMtlContext ctx, float alpha, vec3 alphaDir, vec3 diffuseIndirect) {\n  vec3 res = vec3(0.0);\n \n  if (!params.traceRefractions)\n  return res;\n \n  float invNumSamples = 1.0f / float(nbSamples);\n  vec3 view = -params.Vw;\n \n  if (alpha <= 0.999) {\n  res += envSampleLOD(alphaDir, 0.0);\n  } else {\n  vec3 envSum = vec3(0.0);\n  for (int i = 0; i < nbSamples; ++i) {\n  bool totalInternalReflection;\n  vec3 dir = vraySampleRefractBRDF(params, ctx, i, totalInternalReflection);\n  if (totalInternalReflection) {\n  envSum += envSampleLOD(dir, 0.0);\n  } else {\n  envSum += envSampleLOD(dir, 0.0);\n  }\n  }\n  res += envSum * invNumSamples;\n  }\n \n  return res;\n }\n \n /// Sample texture and blend with default color where no data exists.\n vec3 textureWithDefault(SamplerSparse samplerSparse, SparseCoord coord, vec3 defaultColor) {\n  vec4 sampledColor = textureSparse(samplerSparse, coord);\n  return sampledColor.rgb + (1.0 - sampledColor.a) * defaultColor;\n }\n \n /// Sample texture and blend with default value, treating green as alpha.\n float textureWithDefault(SamplerSparse samplerSparse, SparseCoord coord, float defaultValue) {\n  vec4 sampledValue = textureSparse(samplerSparse, coord);\n  return sampledValue.r + (1.0 - sampledValue.g) * defaultValue;\n }\n \n /// Implemented in specular/metallic\n /// initParams will be set up with geometry data prior to this call\n void setupInitParams(inout VRayMtlInitParams initParams, SparseCoord texCoord);\n`}</code></pre>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#section-5\"\n      }}>{` `}</a></p>\n    <p>{`Shader entry point.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-glsl\"\n      }}>{`void shade(V2F inputs)\n {\n  // Normal with bump/normal map applied\n  vec3 bumpNormal = computeWSNormal(inputs.sparse_coord, inputs.tangent, inputs.bitangent, inputs.normal);\n \n  // Init VRayMtl\n  VRayMtlInitParams initParams;\n \n  // setup geometric data\n  // for 2D put view vector along normal (see lib-vectors)\n  initParams.Vw = is2DView ? bumpNormal : getEyeVec(inputs.position);\n  initParams.geomNormal = bumpNormal;\n  initParams.approxEnv = false;\n \n  // setup common parameters\n  initParams.diffuseAmount = uniform_diffuse_amount;\n  initParams.reflAmount = uniform_reflection_amount;\n  initParams.traceReflections = uniform_trace_reflections;\n  initParams.aniso = 0.0;\n  initParams.anisoRotation = 0.0;\n  initParams.anisoAxis = uniform_anisotropy_axis;\n  initParams.refractionAmount = uniform_refraction_amount;\n  initParams.refractionIOR = uniform_refraction_ior;\n  initParams.refrGloss = uniform_refraction_glossiness;\n  initParams.traceRefractions = uniform_trace_refractions;\n  initParams.useFresnel = uniform_use_fresnel;\n  initParams.fresnelIOR = uniform_fresnel_ior;\n  initParams.lockFresnelIOR = uniform_lock_fresnel_ior;\n  initParams.doubleSided = uniform_double_sided;\n  initParams.useRoughness = false;\n  initParams.gtrGamma = uniform_gtr_gamma;\n  initParams.brdfType = uniform_brdf_type;\n  initParams.opacity = vec3(1.0);\n \n  // flavour-specific setup\n  setupInitParams(initParams, inputs.sparse_coord);\n \n  // Get detail (ambient occlusion) and global (shadow) occlusion factors\n  float occlusion = getAO(inputs.sparse_coord) * getShadowFactor();\n  float specOcclusion = specularOcclusionCorrection(occlusion, initParams.metalness, initParams.useRoughness ? 1.0 - initParams.reflGloss : initParams.reflGloss);\n \n  // Init context and sample material\n  VRayMtlContext ctx = initVRayMtlContext(initParams);\n  vec3 lightDir = uniform_main_light.xyz - inputs.position * uniform_main_light.w;\n  vec3 diffuseDirect = vrayComputeDirectDiffuseContribution(initParams, ctx, lightDir);\n  vec3 diffuseIndirect = vrayComputeIndirectDiffuseContribution(initParams, ctx);\n  vec3 diffuse = diffuseDirect + diffuseIndirect;\n  vec3 reflection =\n  vrayComputeDirectReflectionContribution(initParams, ctx, lightDir) +\n  vrayComputeIndirectReflectionContribution(initParams, ctx);\n  float alpha = intensity(ctx.opacity);\n  vec3 refraction =\n  vrayComputeIndirectRefractionContribution(initParams, ctx, alpha, -initParams.Vw, diffuseIndirect);\n \n  // Output values\n  if (debugOutput == 0) {\n  albedoOutput(ctx.diff);\n  diffuseShadingOutput(occlusion * diffuse);\n  specularShadingOutput(specOcclusion * reflection * ctx.refl);\n  // output refraction with emissive as it can't really go elsewhere\n  emissiveColorOutput(ctx.illum + refraction * ctx.refr);\n  }\n }\n \n \n void setupInitParams(inout VRayMtlInitParams initParams, SparseCoord texCoord) {\n  // Fetch material parameters\n  vec3 baseColor = textureWithDefault(basecolor_tex, texCoord, vec3(0.5));\n  float roughness = textureWithDefault(roughness_tex, texCoord, 0.0);\n  float metallic = textureWithDefault(metallic_tex, texCoord, 0.0);\n  vec3 refractionColor = textureWithDefault(transmissive_tex, texCoord, vec3(0.0));\n  vec3 selfIllumColor = textureWithDefault(emissive_tex, texCoord, vec3(0.0));\n  float anisotropy = textureWithDefault(anisotropylevel_tex, texCoord, 0.0);\n  float anisotropyAngle = textureWithDefault(anisotropyangle_tex, texCoord, 0.0);\n \n  initParams.diffuseColor = baseColor;\n  initParams.roughness = roughness;\n  initParams.selfIllum = selfIllumColor;\n  initParams.reflColor = vec3(1.0);\n  initParams.reflGloss = roughness;\n  initParams.refractionColor = refractionColor;\n  initParams.metalness = metallic;\n  initParams.aniso = anisotropy;\n  initParams.anisoRotation = anisotropyAngle;\n  initParams.useRoughness = true;\n }\n \n \n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","_ref","components","props","_objectWithoutPropertiesLoose","_excluded","mdx","_extends","mdxType","parentName","isMDXComponent"],"sourceRoot":""}