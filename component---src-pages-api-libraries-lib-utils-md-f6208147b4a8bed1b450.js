"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[7742],{35996:function(e,n,r){r.r(n),r.d(n,{_frontmatter:function(){return p},default:function(){return c}});var a=r(87462),l=r(63366),o=(r(15007),r(64983)),t=r(91515),s=["components"],p={},m={_frontmatter:p},i=t.Z;function c(e){var n=e.components,r=(0,l.Z)(e,s);return(0,o.mdx)(i,(0,a.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-0"}," ")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-1"}," ")),(0,o.mdx)("h1",{id:"utility-functions"},"Utility functions"),(0,o.mdx)("h2",{id:"tone-mapping"},"Tone mapping"),(0,o.mdx)("p",null,"These are examples of tone mapping you can use in your shader. Painter doesn't apply any\ntone mapping except the optional one applied by Yebis. If you decide to do some tone mapping\nin your shader, it will be applied before Yebis tone mapping."),(0,o.mdx)("p",null,"Perform the S-curve tone mapping based on the parameters sigma and n."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 tonemapSCurve(vec3 value, float sigma, float n)\n {\n  vec3 pow_value = pow(value, vec3(n));\n  return pow_value / (pow_value + pow(sigma, n));\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-2"}," ")),(0,o.mdx)("h2",{id:"srgb-conversions"},"sRGB conversions"),(0,o.mdx)("p",null,"These are the conversions used in Painter."),(0,o.mdx)("p",null,"sRGB to linear color conversion. Scalar version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"float sRGB2linear(float x)\n {\n  return x <= 0.04045 ?\n  x * 0.0773993808 : // 1.0/12.92\n  pow((x + 0.055) / 1.055, 2.4);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-3"}," ")),(0,o.mdx)("p",null,"sRGB to linear color conversion. RGB version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 sRGB2linear(vec3 rgb)\n {\n  return vec3(\n  sRGB2linear(rgb.r),\n  sRGB2linear(rgb.g),\n  sRGB2linear(rgb.b));\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-4"}," ")),(0,o.mdx)("p",null,"sRGB to linear color conversion. RGB + Alpha version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec4 sRGB2linear(vec4 rgba)\n {\n  return vec4(sRGB2linear(rgba.rgb), rgba.a);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-5"}," ")),(0,o.mdx)("p",null,"Linear to sRGB color conversion. Scalar version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"float linear2sRGB(float x)\n {\n  return x <= 0.0031308 ?\n  12.92 * x :\n  1.055 * pow(x, 0.41666) - 0.055;\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-6"}," ")),(0,o.mdx)("p",null,"Linear to sRGB color conversion. RGB version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 linear2sRGB(vec3 rgb)\n {\n  return vec3(\n  linear2sRGB(rgb.r),\n  linear2sRGB(rgb.g),\n  linear2sRGB(rgb.b));\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-7"}," ")),(0,o.mdx)("p",null,"Linear to sRGB color conversion. RGB + Alpha version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec4 linear2sRGB(vec4 rgba)\n {\n  return vec4(linear2sRGB(rgba.rgb), rgba.a);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-8"}," ")),(0,o.mdx)("p",null,"Linear to sRGB color conversion optional. Scalar version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"//: param auto conversion_linear_to_srgb\n uniform bool convert_to_srgb_opt;\n float linear2sRGBOpt(float x)\n {\n  return convert_to_srgb_opt ? linear2sRGB(x) : x;\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-9"}," ")),(0,o.mdx)("p",null,"Linear to sRGB color conversion optional. RGB version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 linear2sRGBOpt(vec3 rgb)\n {\n  return convert_to_srgb_opt ? linear2sRGB(rgb) : rgb;\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-10"}," ")),(0,o.mdx)("p",null,"Linear to sRGB color conversion optional. RGB + Alpha version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec4 linear2sRGBOpt(vec4 rgba)\n {\n  return convert_to_srgb_opt ? linear2sRGB(rgba) : rgba;\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-11"}," ")),(0,o.mdx)("p",null,"Color conversion. Scalar version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"uniform int output_conversion_method;\n float convertOutput(float x)\n {\n  if (output_conversion_method == 0) return x;\n  else if (output_conversion_method == 1) return linear2sRGB(x);\n  else return sRGB2linear(x);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-12"}," ")),(0,o.mdx)("p",null,"Color conversion. RGB version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 convertOutput(vec3 rgb)\n {\n  if (output_conversion_method == 0) return rgb;\n  else if (output_conversion_method == 1) return linear2sRGB(rgb);\n  else return sRGB2linear(rgb);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-13"}," ")),(0,o.mdx)("p",null,"Color conversion. RGB + Alpha version."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec4 convertOutput(vec4 rgba)\n {\n  if (output_conversion_method == 0) return rgba;\n  else if (output_conversion_method == 1) return linear2sRGB(rgba);\n  else return sRGB2linear(rgba);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-14"}," ")),(0,o.mdx)("h2",{id:"dithering"},"Dithering"),(0,o.mdx)("p",null,"These are some helpers to add dithering to shaders."),(0,o.mdx)("p",null,"Use 8x8 Bayer matrix for dithering mode"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"\n \n float getDitherThreshold(uvec2 coords)\n {\n  return bayerMatrix8(coords);\n }\n \n \n vec4 RGB2Gray(vec4 rgba)\n {\n  float gray = 0.299 * rgba.r + 0.587 * rgba.g + 0.114 * rgba.b;\n  return vec4(vec3(gray), rgba.a);\n }\n")),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"#section-15"}," ")),(0,o.mdx)("p",null,"Remove AO and shadows on glossy metallic surfaces (close to mirrors)"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-glsl"},"float specularOcclusionCorrection(float diffuseOcclusion, float metallic, float roughness)\n {\n  return mix(diffuseOcclusion, 1.0, metallic * (1.0 - roughness) * (1.0 - roughness));\n }\n \n \n")))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-libraries-lib-utils-md-f6208147b4a8bed1b450.js.map