"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[5042],{18368:function(e,r,n){n.r(r),n.d(r,{_frontmatter:function(){return s},default:function(){return i}});var d=n(87462),a=n(63366),t=(n(15007),n(64983)),o=n(91515),l=["components"],s={},m={_frontmatter:s},p=o.Z;function i(e){var r=e.components,n=(0,a.Z)(e,l);return(0,t.mdx)(p,(0,d.Z)({},m,n,{components:r,mdxType:"MDXLayout"}),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-0"}," ")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-1"}," ")),(0,t.mdx)("p",null,"==============="),(0,t.mdx)("p",null,"This file provides useful functions to ensure sparse textures sampling\ncorrectness (ARB_sparse_texture).\nAllows to sample only part of textures really present in video memory."),(0,t.mdx)("p",null,(0,t.mdx)("strong",{parentName:"p"},"Public Functions:"),"\n",(0,t.mdx)("inlineCode",{parentName:"p"},"getSparseCoord"),"\n",(0,t.mdx)("inlineCode",{parentName:"p"},"getSparseCoordLod0"),"\n",(0,t.mdx)("inlineCode",{parentName:"p"},"textureSparseQueryLod"),"\n",(0,t.mdx)("inlineCode",{parentName:"p"},"textureSparse")),(0,t.mdx)("p",null,(0,t.mdx)("strong",{parentName:"p"},"Public Structures:"),"\n",(0,t.mdx)("inlineCode",{parentName:"p"},"SamplerSparse"),"\n",(0,t.mdx)("inlineCode",{parentName:"p"},"SparseCoord")),(0,t.mdx)("p",null,"The ",(0,t.mdx)("inlineCode",{parentName:"p"},"FEATURE_SPARSE_TEXTURE")," macro is defined only if the sparse virtual texture extension is enabled."),(0,t.mdx)("p",null,"If enabled, process additional texture lookup checks to climb up mipmap pyramid if texels are missing."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"#ifdef FEATURE_SPARSE_TEXTURE\n //: param auto material_lod_check_needed\n uniform bool material_lod_check_needed = false;\n //: param auto material_lod_mask\n uniform usampler2D material_lod_mask;\n #endif // FEATURE_SPARSE_TEXTURE\n //: param auto uvtile_reference_sampler\n uniform sampler2D uvtile_reference_sampler;\n //: param auto uvtile_size\n uniform vec2 uvtile_size;\n //: param auto uvtile_inverse_size\n uniform vec2 uvtile_inverse_size;\n //: param auto uvtile_lod_bias\n uniform float uvtile_lod_bias;\n")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-2"}," ")),(0,t.mdx)("p",null,"Sampler and sparse texture information structure"),(0,t.mdx)("p",null,"Used to query all sampler related uniforms with a single auto binding"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"struct SamplerSparse {\n  sampler2D tex;\n  vec4 size; // width, height, 1/width, 1/height\n  bool is_set; // a boolean indicating whether the texture is in the texture set or not\n  bool is_color; // a boolean indicating whether the texture is color (RGBA) or grayscale (R, GB)\n  uvec3 lod_mask_select; // masking operations description allowing to retrieve loaded mipmaps information\n };\n")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-3"}," ")),(0,t.mdx)("p",null,"Sparse sampling coordinates"),(0,t.mdx)("p",null,"Store the UV coordinates & material-wise sparse LoD mask"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"struct SparseCoord {\n  vec2 tex_coord;\n  vec2 dfdx;\n  vec2 dfdy;\n  float lod;\n  uint material_lod_mask;\n };\n \n \n #if defined(SHADER_FRAGMENT)\n")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-4"}," ")),(0,t.mdx)("p",null,"Build texture coordinates structure used by ",(0,t.mdx)("inlineCode",{parentName:"p"},"textureSparse()")," sampling function\n(must be called from fragment shader)"),(0,t.mdx)("p",null,"Example: ",(0,t.mdx)("inlineCode",{parentName:"p"},"SparseCoord uv1coord = getSparseCoord(inputs.multi_tex_coord[1]);")),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"SparseCoord getSparseCoord(vec2 tex_coord) {\n  SparseCoord res;\n  res.tex_coord = tex_coord;\n  res.dfdx = dFdx(tex_coord);\n  res.dfdy = dFdy(tex_coord);\n #ifdef FEATURE_SPARSE_TEXTURE\n  res.material_lod_mask = material_lod_check_needed ?\n  textureLod(material_lod_mask,tex_coord,0.0).r :\n  0u;\n  res.lod = getLodFromReferenceSampler(tex_coord);\n #endif // FEATURE_SPARSE_TEXTURE\n  return res;\n }\n #endif\n")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-5"}," ")),(0,t.mdx)("p",null,"Build texture coordinates structure used by ",(0,t.mdx)("inlineCode",{parentName:"p"},"textureSparse()")," sampling function\nBase level sampling version (can be used if outside fragment shader)"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"SparseCoord getSparseCoordLod0(vec2 tex_coord) {\n  SparseCoord res;\n  res.tex_coord = tex_coord;\n  res.dfdx = vec2(0.0);\n  res.dfdy = vec2(0.0);\n #ifdef FEATURE_SPARSE_TEXTURE\n  res.material_lod_mask = material_lod_check_needed ?\n  textureLod(material_lod_mask,tex_coord,0.0).r :\n  0u;\n  res.lod = 0.0;\n #endif // FEATURE_SPARSE_TEXTURE\n  return res;\n }\n \n #if defined(SHADER_FRAGMENT)\n")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-6"}," ")),(0,t.mdx)("p",null,"Compute the level-of-detail that would be used to sample from a sparse texture"),(0,t.mdx)("p",null,"Climb up mipmap pyramid if texels are missing\nReturns LoD BEFORE LoD bias applied"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"float textureSparseQueryLod(SamplerSparse smp, SparseCoord coord) {\n #ifdef FEATURE_SPARSE_TEXTURE\n  float lodfix = coord.lod;\n  if (material_lod_check_needed) {\n  lodfix = getFixedSparseLod(getTextureLodMask(smp.lod_mask_select, coord.material_lod_mask), lodfix);\n  }\n  return lodfix-uvtile_lod_bias;\n #else // FEATURE_SPARSE_TEXTURE\n  // Do not use textureQueryLod here: workaround of MacOS driver issue (dramatic FPS drop)\n  vec2 dx = coord.dfdx * smp.size.xy;\n  vec2 dy = coord.dfdy * smp.size.xy;\n  return max(0.0, 0.5 * log2(max(dot(dx, dx), dot(dy, dy))));\n #endif // FEATURE_SPARSE_TEXTURE\n }\n #endif // SHADER_FRAGMENT\n")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-7"}," ")),(0,t.mdx)("p",null,"Compute the derivatives that would be used to sample from a sparse texture"),(0,t.mdx)("p",null,"Climb up mipmap pyramid if texels are missing"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"void textureSparseQueryGrad(out vec2 dfdx, out vec2 dfdy, SamplerSparse smp, SparseCoord coord) {\n #ifdef FEATURE_SPARSE_TEXTURE\n  if (material_lod_check_needed) {\n  float lodfix = getFixedSparseLod(getTextureLodMask(smp.lod_mask_select, coord.material_lod_mask), coord.lod);\n  if (coord.lod!=lodfix) {\n  // Fix dfdx dfdy, take account offset, no more anisotropy\n  vec2 ddfix = exp2(lodfix-uvtile_lod_bias) * uvtile_inverse_size;\n  dfdx = vec2(ddfix.x,0.0);\n  dfdy = vec2(0.0,ddfix.y);\n  return;\n  }\n  }\n #endif // FEATURE_SPARSE_TEXTURE\n  dfdx = coord.dfdx;\n  dfdy = coord.dfdy;\n }\n")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-8"}," ")),(0,t.mdx)("p",null,"Performs a texture lookup on a sparse texture, go up the mipmap levels if necessary"),(0,t.mdx)("p",null,"This function replaces the standard ",(0,t.mdx)("inlineCode",{parentName:"p"},"texture(sampler2D, vec2)")," to retrieve texels from a sparse texture"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec4 textureSparse(SamplerSparse smp, SparseCoord coord) {\n  vec2 dfdx,dfdy;\n  textureSparseQueryGrad(dfdx, dfdy, smp, coord);\n  return textureGrad(smp.tex, coord.tex_coord, dfdx, dfdy);\n }\n")),(0,t.mdx)("p",null,(0,t.mdx)("a",{parentName:"p",href:"#section-9"}," ")),(0,t.mdx)("p",null,"Given a texture, performs an optimized multiple texture lookups with small offsets"),(0,t.mdx)("p",null,"We are providing alternatives versions of this helper for up to N=4"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"void textureSparseOffsets(SamplerSparse smp, SparseCoord coord, vec2 offsets[N], out vec4 results[N]) {\n  vec2 dfdx,dfdy;\n  textureSparseQueryGrad(dfdx, dfdy, smp, coord);\n  for(int i = 0; i < N; ++i) {\n  results[i] = textureGrad(smp.tex, coord.tex_coord + offsets[i], dfdx, dfdy);\n  }\n }\n \n \n")))}i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-libraries-lib-sparse-md-b2a635b0e1d7a669e8a8.js.map