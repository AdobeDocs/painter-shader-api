"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[3289],{31602:function(e,a,n){n.r(a),n.d(a,{_frontmatter:function(){return p},default:function(){return i}});var l=n(87462),o=n(63366),t=(n(15007),n(64983)),r=n(91515),s=["components"],p={},c={_frontmatter:p},u=r.Z;function i(e){var a=e.components,n=(0,o.Z)(e,s);return(0,t.mdx)(u,(0,l.Z)({},c,n,{components:a,mdxType:"MDXLayout"}),(0,t.mdx)("h1",{id:"substance-3d-painter-metalrough-and-opacity-pbr-shader"},"Substance 3D Painter Metal/Rough and opacity PBR shader"),(0,t.mdx)("hr",null),(0,t.mdx)("p",null,"Import from libraries."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},'import lib-pbr.glsl\n import lib-bent-normal.glsl\n import lib-emissive.glsl\n import lib-pom.glsl\n import lib-utils.glsl\n \n // Link Metal/Roughness MDL for Iray\n //: metadata {\n //:   "mdl":"mdl::alg::materials::physically_metallic_roughness::physically_metallic_roughness"\n //: }\n')),(0,t.mdx)("p",null,"Show back faces as there may be holes in front faces."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"//: state cull_face off\n")),(0,t.mdx)("p",null,"Enable alpha blending"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"//: state blend over\n")),(0,t.mdx)("p",null,"Channels needed for metal/rough workflow are bound here."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"//: param auto channel_basecolor\n uniform SamplerSparse basecolor_tex;\n //: param auto channel_roughness\n uniform SamplerSparse roughness_tex;\n //: param auto channel_metallic\n uniform SamplerSparse metallic_tex;\n //: param auto channel_specularlevel\n uniform SamplerSparse specularlevel_tex;\n //: param auto channel_opacity\n uniform SamplerSparse opacity_tex;\n")),(0,t.mdx)("p",null,"Shader entry point."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-glsl"},"void shade(V2F inputs)\n {\n   // Apply parallax occlusion mapping if possible\n   vec3 viewTS = worldSpaceToTangentSpace(getEyeVec(inputs.position), inputs);\n   applyParallaxOffset(inputs, viewTS);\n \n   // Fetch material parameters, and conversion to the specular/roughness model\n   float roughness = getRoughness(roughness_tex, inputs.sparse_coord);\n   vec3 baseColor = getBaseColor(basecolor_tex, inputs.sparse_coord);\n   float metallic = getMetallic(metallic_tex, inputs.sparse_coord);\n   float specularLevel = getSpecularLevel(specularlevel_tex, inputs.sparse_coord);\n \n   vec3 diffColor = generateDiffuseColor(baseColor, metallic);\n   vec3 specColor = generateSpecularColor(specularLevel, baseColor, metallic);\n \n   // Get detail (ambient occlusion) and global (shadow) occlusion factors\n   // separately in order to blend the bent normals properly\n   float shadowFactor = getShadowFactor();\n   float occlusion = getAO(inputs.sparse_coord, true, use_bent_normal);\n   float specOcclusion = specularOcclusionCorrection(\n     use_bent_normal ? shadowFactor : occlusion * shadowFactor,\n     metallic,\n     roughness);\n \n   LocalVectors vectors = computeLocalFrame(inputs);\n   computeBentNormal(vectors,inputs);\n \n   // Feed parameters for a physically based BRDF integration\n   alphaOutput(getOpacity(opacity_tex, inputs.sparse_coord));\n   emissiveColorOutput(pbrComputeEmissive(emissive_tex, inputs.sparse_coord));\n   diffuseShadingOutput(occlusion * shadowFactor * pbrComputeDiffuse(getDiffuseBentNormal(vectors), diffColor));\n   specularShadingOutput(specOcclusion * pbrComputeSpecular(vectors, specColor, roughness, occlusion, getBentNormalSpecularAmount()));\n }\n \n \n")))}i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-shaders-pbr-metal-rough-with-alpha-blending-md-c100eabcc3434ff4123e.js.map