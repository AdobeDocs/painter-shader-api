"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[1099],{10779:function(e,n,r){r.r(n),r.d(n,{_frontmatter:function(){return d},default:function(){return s}});var a=r(87462),t=r(63366),m=(r(15007),r(64983)),o=r(91515),i=["components"],d={},l={_frontmatter:d},p=o.Z;function s(e){var n=e.components,r=(0,t.Z)(e,i);return(0,m.mdx)(p,(0,a.Z)({},l,r,{components:n,mdxType:"MDXLayout"}),(0,m.mdx)("p",null,(0,m.mdx)("a",{parentName:"p",href:"#section-0"}," ")),(0,m.mdx)("p",null,(0,m.mdx)("a",{parentName:"p",href:"#section-1"}," ")),(0,m.mdx)("h1",{id:"lib-envglsl"},"lib-env.glsl"),(0,m.mdx)("hr",null),(0,m.mdx)("p",null,(0,m.mdx)("strong",{parentName:"p"},"Public Functions:"),"\n",(0,m.mdx)("inlineCode",{parentName:"p"},"envSample"),"\n",(0,m.mdx)("inlineCode",{parentName:"p"},"envIrradiance"),"\n",(0,m.mdx)("inlineCode",{parentName:"p"},"worldToEnvSpace")),(0,m.mdx)("p",null,"Needed for math constants"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-glsl"},"import lib-defines.glsl\n")),(0,m.mdx)("p",null,(0,m.mdx)("a",{parentName:"p",href:"#section-2"}," ")),(0,m.mdx)("p",null,"Engine provided parameters"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-glsl"},"//: param auto texture_environment\n uniform sampler2D environment_texture;\n //: param auto environment_matrix\n uniform mat3 environment_matrix;\n //: param auto environment_exposure\n uniform float environment_exposure;\n //: param auto environment_irrad_mat_red\n uniform mat4 irrad_mat_red;\n //: param auto environment_irrad_mat_green\n uniform mat4 irrad_mat_green;\n //: param auto environment_irrad_mat_blue\n uniform mat4 irrad_mat_blue;\n")),(0,m.mdx)("p",null,(0,m.mdx)("a",{parentName:"p",href:"#section-3"}," ")),(0,m.mdx)("p",null,"Helper that allows one to sample environment. Rotation is taken into\naccount. The environment map is a panoramic env map behind the scene,\nthat's why there is extra computation from dir vector.\nDirection must be in environment space (using worldToEnvSpace function)"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 envSample(vec3 dir, float lod)\n {\n  // WORKAROUND: Intel GLSL compiler for HD5000 is bugged on OSX:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=308366\n  // It is necessary to replace atan(y, -x) by atan(y, -1.0 * x) to force\n  // the second parameter to be interpreted as a float\n  vec2 pos = M_INV_PI * vec2(atan(-dir.z, -1.0 * dir.x), 2.0 * asin(dir.y));\n  pos = 0.5 * pos + vec2(0.5);\n  return textureLod(environment_texture, pos, lod).rgb * environment_exposure;\n }\n")),(0,m.mdx)("p",null,(0,m.mdx)("a",{parentName:"p",href:"#section-4"}," ")),(0,m.mdx)("p",null,"Transform a direction from world to environment space"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 worldToEnvSpace(vec3 dirW)\n {\n  return environment_matrix * dirW;\n }\n")),(0,m.mdx)("p",null,(0,m.mdx)("a",{parentName:"p",href:"#section-5"}," ")),(0,m.mdx)("p",null,"Return the irradiance for a given direction. The computation is based on\nenvironment's spherical harmonics projection.\nDirection in world space"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-glsl"},"vec3 envIrradiance(vec3 dirW)\n {\n  vec4 shDir = vec4(worldToEnvSpace(dirW).xzy, 1.0);\n  return max(vec3(0.0), vec3(\n  dot(shDir, irrad_mat_red * shDir),\n  dot(shDir, irrad_mat_green * shDir),\n  dot(shDir, irrad_mat_blue * shDir)\n  )) * environment_exposure;\n }\n \n \n")))}s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-libraries-lib-env-md-0018200a26a357592b0b.js.map